INCLUDE "RIPTIDE-III.INC"

;VARIABLES
DUMP_START_LOW		EQU $F000
DUMP_START_HIGH		EQU $F001
DUMP_END_LOW		EQU $F002
DUMP_END_HIGH		EQU $F003

DISPLAY_COUNT_L	EQU $F004
DISPLAY_COUNT_H	EQU $F005

DISPLAY_CELL_X	EQU $F006
DISPLAY_CELL_Y	EQU $F007
DISPLAY_CELL_VALUE	EQU $F008
DISPLAY_ELEMENT_X	EQU $F009
DISPLAY_ELEMENT_Y	EQU $F00A
DISPLAY_ELEMENT_VALUE	EQU $F00B
DISPLAY_CURSOR_X	EQU $F00C
DISPLAY_CURSOR_Y	EQU $F00D

PREV_VSYNC	EQU $F00E
PREV_HSYNC	EQU $F00F
FRAME_COUNT	EQU $F010

RND_L	EQU $F011
RND_H	EQU $F012

HEX_BUF_L	EQU $F013
HEX_BUF_H	EQU $F014

STR_BUF	EQU $F020
STR_BUF_END	EQU $F050
STR_BUF_OFFSET	EQU $F051

KB_STATE	EQU $F052
KB_FIRST_BUF	EQU $F053
KB_SECOND_BUF	EQU $F054
KB_FIRST	EQU $F055
KB_SECOND	EQU $F056
KB_THIRD	EQU $F057

KEY_FLAGS	EQU $F058
;	BIT 0: RIGHT ARROW
;	BIT 1: LEFT ARROW
;	BIT 2: DOWN ARROW
;	BIT 3: UP ARROW
;	BIT 4: SHIFT KEY
;	BIT 5: ENTER KEY

SCORE	EQU $F059
HIGH_SCORE	EQU $F05A
PLAYFIELD	EQU $F05B
PLAYFIELD_END	EQU $F85B
HEAD_X	EQU $F85B
HEAD_Y	EQU $F85C
TAIL_X	EQU $F85D
TAIL_Y	EQU $F85E
HEAD_DIRECTION	EQU $F85F
TAIL_DIRECTION	EQU $F860
TARGET_X	EQU $F863
TARGET_Y	EQU $F864

AUX_SAVE_LOC	EQU $F865
R1_SAVE_LOC		EQU $F866
R2_SAVE_LOC		EQU $F867
R3_SAVE_LOC		EQU $F868
R4_SAVE_LOC		EQU $F869
R5_SAVE_LOC		EQU $F86A
R6_SAVE_LOC		EQU $F86B
ADDR_HIGH_SAVE_LOC	EQU $F86C
OVF_SAVE_LOC	EQU $F86D
R11_SAVE_LOC	EQU $F86E
R12_SAVE_LOC	EQU $F86F
R13_SAVE_LOC	EQU $F870
R14_SAVE_LOC	EQU $F871
ADDR_LOW_SAVE_LOC	EQU $F872

;CONSTANTS
KB_READ_FIRST	EQU $00
KB_READ_SECOND	EQU $01
KB_READ_THIRD	EQU $02

SG4_BLACK	EQU $00
SG4_YELLOW	EQU $01
SG4_BLUE	EQU $02
SG4_RED		EQU $03
SG4_BUFF	EQU $04
SG4_CYAN	EQU $05
SG4_MAGENTA	EQU $06
SG4_ORANGE	EQU $07
SG4_GREEN	EQU $08

	ORG 0
	JMP INT_RESET
	RET	;INT1
	JMP INT_VSYNC
	RET	;INT3
	RET	;INT4
	RET	;INT5
	RET	;INT6
	RET	;INT7

INT_RESET
	XMIT `HIGH INTERRUPT_STATUS, ADDR_HIGH
	XMIT `LOW INTERRUPT_STATUS, ADDR_LOW
	XMIT $00, IO0, 0
	XMIT `HIGH INTERRUPT_CONTROL, ADDR_HIGH
	XMIT `LOW INTERRUPT_CONTROL, ADDR_LOW
	XMIT %0000 0001, IO0, 0
	JMP INIT

INT_VSYNC
; SAVE ALL REGISTERS
	MOVE ADDR_HIGH, R15
	MOVE ADDR_LOW, R16
	XMIT `HIGH AUX_SAVE_LOC, ADDR_HIGH
	XMIT `LOW AUX_SAVE_LOC, ADDR_LOW
	MOVE AUX, DATA0
	XMIT `LOW R1_SAVE_LOC, ADDR_LOW
	MOVE R1, DATA0
	XMIT `LOW R2_SAVE_LOC, ADDR_LOW
	MOVE R2, DATA0
	XMIT `LOW R3_SAVE_LOC, ADDR_LOW
	MOVE R3, DATA0
	XMIT `LOW R4_SAVE_LOC, ADDR_LOW
	MOVE R4, DATA0
	XMIT `LOW R5_SAVE_LOC, ADDR_LOW
	MOVE R5, DATA0
	XMIT `LOW R6_SAVE_LOC, ADDR_LOW
	MOVE R6, DATA0
	XMIT `LOW OVF_SAVE_LOC, ADDR_LOW
	MOVE OVF, DATA0
	XMIT `LOW R11_SAVE_LOC, ADDR_LOW
	MOVE R11, DATA0
	XMIT `LOW R12_SAVE_LOC, ADDR_LOW
	MOVE R12, DATA0
	XMIT `LOW R13_SAVE_LOC, ADDR_LOW
	MOVE R13, DATA0
	XMIT `LOW R14_SAVE_LOC, ADDR_LOW
	MOVE R14, DATA0
; RUN VSYNC CODE
	XMIT `HIGH HEX_INC, AUX
	CALL HEX_INC	;04
	XMIT `HIGH FRAME_COUNT, ADDR_HIGH
	XMIT `LOW FRAME_COUNT, ADDR_LOW
	XMIT $01, AUX
	XMIT 30, R5
	ADD DATA0, 8, R4	;GET AND INCREMENT FRAME COUNTER
	XMIT `HIGH DIV8, AUX
	CALL DIV8	;COMPUTE FRAME_COUNT % 60
	MOVE R4, 8, DATA0	;STORE RESULT IN FRAME COUNTER
	NZT R4, IV_NZ	;IF FRAME_COUNT NOT ZERO JUMP TO IV_NZ
	;XMIT `HIGH M_RING_2, AUX
	;CALL M_RING_2	;ELSE CALL M_RING_2
	XMIT `HIGH MR2_TEST, AUX
	CALL MR2_TEST
	;XMIT `HIGH SNAKE_DUMP, AUX
	;CALL SNAKE_DUMP
IV_NZ
; TURN OFF ALL INTERRUPTS
	XMIT `HIGH INTERRUPT_CONTROL, ADDR_HIGH
	XMIT `LOW INTERRUPT_CONTROL, ADDR_LOW
	XMIT %1111 1110, AUX
	MOVE IO0, 8, R1	;SAVE ORIGINAL INTERRUPT_CONTROL TO R1
	AND IO0, 8, IO0
; CLEAR VSYNC INTERRUPT FLAG
	XMIT `LOW INTERRUPT_STATUS, ADDR_LOW
	XMIT %1111 1011, AUX
	AND IO0, 8, AUX	;SAVE INTERRUPT_STATUS TO AUX
	MOVE AUX, 8, IO0
; CHECK FOR OTHER INTERRUPTS
	AND R1, AUX	; AND ORIGINAL INTERRUPT_CONTROL WITH INTERRUPT_STATUS
	NZT AUX, INT_GENERIC	;HANDLE OTHER INTERRUPTS
; RESTORE REGISTERS
IV_RESTORE
	XMIT `HIGH R1_SAVE_LOC, ADDR_HIGH
	XMIT `LOW R1_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R1
	XMIT `LOW R2_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R2
	XMIT `LOW R3_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R3
	XMIT `LOW R4_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R4
	XMIT `LOW R5_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R5
	XMIT `LOW R6_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R6
	XMIT `LOW OVF_SAVE_LOC, ADDR_LOW
	XMIT $FF, AUX
	ADD DATA0, 8, AUX	;OVF IS NOT DIRECTLY WRITABLE
	XMIT `LOW R11_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R11
	XMIT `LOW R12_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R12
	XMIT `LOW R13_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R13
	XMIT `LOW R14_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R14
	XMIT `LOW AUX_SAVE_LOC, ADDR_LOW
	MOVE DATA0, AUX	;AUX MUST BE RESTORED AFTER RESTORING OVF
; ENABLE INTERRUPTS
	XMIT `HIGH INTERRUPT_CONTROL, ADDR_HIGH
	XMIT `LOW INTERRUPT_CONTROL, ADDR_LOW
	MOVE IO0, 8, IO0	;MOVE CURRENT VALUE OF INTERRUPT_CONTROL INTO IO LATCH
	XMIT $01, IO0, 1	;ADDRESS REGISTERS WILL BE RESTORED BEFOR THIS REACHES THE END OF THE PIPELINE
	MOVE R15, ADDR_HIGH
	MOVE R16, ADDR_LOW
	RET

INT_GENERIC
; NOT YET IMPLEMENTED
	XMIT `HIGH INTERRUPT_STATUS, ADDR_HIGH
	XMIT `LOW INTERRUPT_STATUS, ADDR_LOW
	XMIT $00, IO0, 0
	JMP IV_RESTORE

	ORG $0100
INIT
	XMIT $00, AUX
	XMIT $00, R1
	XMIT $00, R2
	XMIT $00, R3
	XMIT $00, R4
	XMIT $00, R5
	XMIT $00, R6
	XMIT $00, R11	;INITIALIZE REGISTERS

	XMIT `HIGH MSC_D_CONTROL, ADDR_HIGH
	XMIT `LOW MSC_D_CONTROL, ADDR_LOW
	XMIT $08, IO0, 8	;ENABLE DATA CACHE CONTROL

	XMIT `LOW MSC_D_PAGE, ADDR_LOW
	XMIT $02, IO0, 8	;SWITCH TO DATA PAGE 2

	XMIT `LOW MSC_D_CONTROL, ADDR_LOW
	XMIT $01, IO0, 8	;RESET DATA CACHE AND DISABLE CONTROL

	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	MOVE DATA0, 8, AUX	;HOLD UNTIL RESET IS DONE

	XMIT `HIGH HEX_BUF_H, ADDR_HIGH
	XMIT `LOW HEX_BUF_H, ADDR_LOW
	XMIT $00, DATA0, 8	;CLEAR HEX HIGH
	XMIT `HIGH HEX_BUF_L, ADDR_HIGH
	XMIT `LOW HEX_BUF_L, ADDR_LOW
	XMIT $00, DATA0, 8	;CLEAR HEX LOW

	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	XMIT $00, DATA0, 8
	XMIT `HIGH RND_H, ADDR_HIGH
	XMIT `LOW RND_H, ADDR_LOW
	XMIT $00, DATA0, 8

	XMIT `HIGH KB_STATE, ADDR_HIGH
	XMIT `LOW KB_STATE, ADDR_LOW
	XMIT $00, DATA0, 8

	XMIT `HIGH KEY_FLAGS, ADDR_HIGH
	XMIT `LOW KEY_FLAGS, ADDR_LOW
	XMIT $00, DATA0, 8

	XMIT `HIGH HEX_INC, AUX
	CALL HEX_INC	;01

	;INITIALIZE DISPLAY IN SEMI-GRAPHICS 4 MODE
	XMIT $8F, R3
	XMIT `HIGH DISPLAY_INIT_SG4, AUX
	CALL DISPLAY_INIT_SG4

	XMIT `HIGH HEX_INC, AUX
	CALL HEX_INC	;02

	JMP MAIN

HEX_INC
	XMIT `HIGH HEX_BUF_L, ADDR_HIGH
	XMIT `LOW HEX_BUF_L, ADDR_LOW
	XMIT $01, AUX
	ADD DATA0, 8, AUX
	MOVE AUX, 8, DATA0
	XMIT `HIGH HEX_LOW, ADDR_HIGH
	XMIT `LOW HEX_LOW, ADDR_LOW
	MOVE AUX, 8, IO0
	XMIT `HIGH HEX_BUF_H, ADDR_HIGH
	XMIT `LOW HEX_BUF_H, ADDR_LOW
	MOVE OVF, AUX
	ADD DATA0, 8, AUX
	MOVE AUX, 8, DATA0
	XMIT `HIGH HEX_HIGH, ADDR_HIGH
	XMIT `LOW HEX_HIGH, ADDR_LOW
	MOVE AUX, 8, IO0
	RET

DISPLAY_INIT_SG4
;SET ALL CHARS TO 0X8F
;32 * 16 = 512 CHARS
	XMIT $00, R1	;LOW COUNTER
	XMIT $00, R2	;HIGH COUNTER
	XMIT $01, AUX	;IMPLICIT OPERAND FOR INCREMENTS
DI_LOOP
	MOVE R2, IVL
	MOVE R1, IVR
	MOVE R3, 8, IO0
	ADD R1, R1
	NZT R1, DI_LOOP
	NZT R2, DI_DONE
	ADD R2, R2
	JMP DI_LOOP
DI_DONE
	RET

RND_GET_WORD
	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	XMIT $01, AUX
	XOR DATA0, 1, AUX
	XOR DATA7, 1, AUX	;COMPUTE NEW MSB AND PUT IT IN AUX
	XMIT `HIGH RND_H, ADDR_HIGH
	XMIT `LOW RND_H, ADDR_LOW
	MOVE DATA0, 1, R11	;STORE LSB OF RND_H IN R11
	MOVE DATA1, 7, DATA0	;RIGHT SHIFT RND_H
	MOVE AUX, 1, DATA7	;STORE NEW MSB IN RND_H
	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	MOVE DATA1, 7, DATA0	;RIGHT SHIFT RND_L
	MOVE R11, 1, DATA7	;STORE LSB OF RND_H IN RND_L
	RET

RND_BUILD_BYTE
	XMIT $08, R6
	JMP RND_BUILD_LOOP
RND_BUILD_WORD
	XMIT $10, R6
RND_BUILD_LOOP
	XMIT `HIGH RND_GET_WORD, AUX
	CALL RND_GET_WORD
	XMIT $FF, AUX
	ADD R6, R6
	NZT R6, RND_BUILD_LOOP
	RET

TEMP EQU R3
NUMERATOR EQU R4
DENOMINATOR EQU R5
INDEX EQU R6
RESULT EQU R11

DIV8
	NZT DENOMINATOR, DIV8_NZ
	RET	;IF DENOMINATOR IS ZERO RETURN
DIV8_NZ
	XMIT $00, RESULT
	XMIT $01, INDEX	;INITIALIZE RESULT AND INDEX
SHIFT_IT8
	XMIT $80, AUX
	AND DENOMINATOR, AUX
	NZT AUX, DIV8LOOP	;IF MSB OF DENOMINATOR IS SET GOTO DIV8LOOP
	MOVE INDEX, AUX
	ADD INDEX, INDEX
	MOVE DENOMINATOR, AUX
	ADD DENOMINATOR, DENOMINATOR	;LEFT-SHIFT DENOMINATOR AND INDEX
	JMP SHIFT_IT8
DIV8LOOP
	XMIT $FF, AUX
	XOR DENOMINATOR, TEMP
	XMIT $01, AUX
	ADD TEMP, TEMP	;MAKE DENOMINATOR NEGATIVE AND STORE IT IN TEMP
	MOVE NUMERATOR, AUX
	ADD TEMP, TEMP	;SUBTRACT DENOMINATOR FROM NUMERATOR AND STORE RESULT IN TEMP
	XMIT $01, AUX
	XOR OVF, AUX	;FLIP CARRY BIT
	NZT AUX, FINAL8	;IF RESULT IS NEGATIVE GOTO FINAL8
	MOVE TEMP, NUMERATOR	;MAKE THE RESULT THE NEW NUMERATOR
	MOVE INDEX, AUX
	ADD RESULT, RESULT	;ADD INDEX TO THE RESULT
FINAL8
	XMIT $7F, AUX
	AND DENOMINATOR(1), DENOMINATOR
	AND INDEX(1), INDEX
	NZT INDEX, DIV8LOOP
	RET

MUL_IN_A EQU R3
MUL_IN_B_H EQU R4
MUL_IN_B_L EQU R5
MUL_OUT_H EQU R6
MUL_OUT_L EQU R11

MUL_8_16
	XMIT $00, MUL_OUT_H
	XMIT $00, MUL_OUT_L
MACC_8_16
	XMIT $01, AUX
	AND MUL_IN_A, AUX	;CHECK IF LSB OF IN_A IS SET
	NZT AUX, MACC_8_16_ADD	;IF IT IS ADD IN_B TO RESULT
;THE FOLLOWING CODE IS DUPLICATED FOR PERFORMANCE REASONS
	XMIT $7F, AUX
	AND MUL_IN_A(1), MUL_IN_A	;RIGHT SHIFT IN_A
	MOVE MUL_IN_B_H, AUX
	ADD MUL_IN_B_H, MUL_IN_B_H
	MOVE MUL_IN_B_L, AUX
	ADD MUL_IN_B_L, MUL_IN_B_L
	MOVE OVF, AUX
	ADD MUL_IN_B_H, MUL_IN_B_H	;LEFT SHIFT IN_B
	NZT MUL_IN_A, MACC_8_16
	RET
MACC_8_16_ADD
	MOVE MUL_IN_B_H, AUX
	ADD MUL_OUT_H, MUL_OUT_H
	MOVE MUL_IN_B_L, AUX
	ADD MUL_OUT_L, MUL_OUT_L
	MOVE OVF, AUX
	ADD MUL_OUT_H, MUL_OUT_H	;ADD MUL_IN_B TO MUL_OUT
;THE FOLLOWING CODE IS DUPLICATED FOR PERFORMANCE REASONS
	XMIT $7F, AUX
	AND MUL_IN_A(1), MUL_IN_A	;RIGHT SHIFT IN_A
	MOVE MUL_IN_B_H, AUX
	ADD MUL_IN_B_H, MUL_IN_B_H
	MOVE MUL_IN_B_L, AUX
	ADD MUL_IN_B_L, MUL_IN_B_L
	MOVE OVF, AUX
	ADD MUL_IN_B_H, MUL_IN_B_H	;LEFT SHIFT IN_B
	NZT MUL_IN_A, MACC_8_16
	RET

	ORG $0200
KB_UPDATE
; CHECK THAT KB HOST IS READY
	XMIT `HIGH KB_STATUS, ADDR_HIGH
	XMIT `LOW KB_STATUS, ADDR_LOW	;KB STATUS REGISTER ADDRESS
	MOVE IO3, 1, R11	;READ RX DONE BIT
	NZT R11, KU_HAS_DATA	;IF READY PROCESS THE SCAN CODE
;ELSE
	XMIT `HIGH KB_FIRST, ADDR_HIGH
	XMIT `LOW KB_FIRST, ADDR_LOW
	XMIT $00, DATA0	;CLEAR KB_FIRST
	XMIT `HIGH KB_SECOND, ADDR_HIGH
	XMIT `LOW KB_SECOND, ADDR_LOW
	XMIT $00, DATA0	;CLEAR KB_SECOND
	XMIT `HIGH KB_THIRD, ADDR_HIGH
	XMIT `LOW KB_THIRD, ADDR_LOW
	XMIT $00, DATA0	;CLEAR KB_THIRD
	RET
KU_HAS_DATA
	XMIT `HIGH KB_DATA, ADDR_HIGH
	XMIT `LOW KB_DATA, ADDR_LOW
	MOVE IO0, 8, R11	;PUT SCAN CODE IN R11

	XMIT `HIGH KB_STATE, ADDR_HIGH
	XMIT `LOW KB_STATE, ADDR_LOW
	MOVE DATA0, 8, R6	;PUT STATE IN R6
	XEC KU_SWITCH (R6)
KU_SWITCH
	JMP KU_PROCESS_FIRST
	JMP KU_PROCESS_SECOND
	JMP KU_PROCESS_THIRD
KU_PROCESS_FIRST
	XMIT $E0, AUX
	XOR R11, R5
	NZT R5, KU_PF_IF2
	JMP KU_PF_FETCH	;IF SCAN CODE IS $E0 FETCH MORE BYTES
KU_PF_IF2	;ELSE CHECK IF SCAN CODE IS $F0
	XMIT $F0, AUX
	XOR R11, R5
	NZT R5, KU_PF_ELSE	;IF SCAN CODE NOT $E0 OR $F0 OUTPUT SINGLE BYTE CODE
KU_PF_FETCH	;IF SCAN CODE IS $E0 OR $F0 FETCH MORE BYTES
	XMIT `HIGH KB_STATE, ADDR_HIGH
	XMIT `LOW KB_STATE, ADDR_LOW
	XMIT KB_READ_SECOND, DATA0	;SET STATE TO KB_READ_SECOND
	XMIT `HIGH KB_FIRST_BUF, ADDR_HIGH
	XMIT `LOW KB_FIRST_BUF, ADDR_LOW
	MOVE R11, 8, DATA0	;PUT SCAN CODE IN KB_FIRST_BUF
	RET
KU_PF_ELSE
	XMIT `HIGH KB_FIRST, ADDR_HIGH
	XMIT `LOW KB_FIRST, ADDR_LOW
	MOVE R11, 8, DATA0	;PUT SCAN CODE IN KB_FIRST
	RET
KU_PROCESS_SECOND
	XMIT $F0, AUX
	XOR R11, R5
	NZT R5, KU_PS_ELSE	
	;IF SCAN CODE IS $F0
	XMIT `HIGH KB_STATE, ADDR_HIGH
	XMIT `LOW KB_STATE, ADDR_LOW
	XMIT KB_READ_THIRD, DATA0	;SET STATE TO KB_READ_THIRD
	XMIT `HIGH KB_SECOND_BUF, ADDR_HIGH
	XMIT `LOW KB_SECOND_BUF, ADDR_LOW
	MOVE R11, 8, DATA0	;PUT SCAN CODE IN KB_SECOND_BUF
	RET
KU_PS_ELSE
	XMIT `HIGH KB_STATE, ADDR_HIGH
	XMIT `LOW KB_STATE, ADDR_LOW
	XMIT KB_READ_FIRST, DATA0
	XMIT `HIGH KB_FIRST_BUF, ADDR_HIGH
	XMIT `LOW KB_FIRST_BUF, ADDR_LOW
	MOVE DATA0, 8, R5	;PUT KB_FIRST_BUF IN R5
	XMIT `HIGH KB_FIRST, ADDR_HIGH
	XMIT `LOW KB_FIRST, ADDR_LOW
	MOVE R5, 8, DATA0	;PUT KB_FIRST_BUF IN KB_FIRST
	XMIT `HIGH KB_SECOND, ADDR_HIGH
	XMIT `LOW KB_SECOND, ADDR_LOW
	MOVE R11, 8, DATA0	;PUT SCAN CODE IN KB_SECOND
	RET
KU_PROCESS_THIRD
	XMIT `HIGH KB_STATE, ADDR_HIGH
	XMIT `LOW KB_STATE, ADDR_LOW
	XMIT KB_READ_FIRST, DATA0	;SET KB_STATE TO KB_READ_THIRD
	XMIT `HIGH KB_FIRST_BUF, ADDR_HIGH
	XMIT `LOW KB_FIRST_BUF, ADDR_LOW
	MOVE DATA0, 8, R5	;PUT KB_FIRST_BUF IN R5
	XMIT `HIGH KB_FIRST, ADDR_HIGH
	XMIT `LOW KB_FIRST, ADDR_LOW
	MOVE R5, 8, DATA0	;PUT KB_FIRST_BUF IN KB_FIRST
	XMIT `HIGH KB_SECOND_BUF, ADDR_HIGH
	XMIT `LOW KB_SECOND_BUF, ADDR_LOW
	MOVE DATA0, 8, R5	;PUT KB_SECOND_BUF IN R5
	XMIT `HIGH KB_SECOND, ADDR_HIGH
	XMIT `LOW KB_SECOND, ADDR_LOW
	MOVE R5, 8, DATA0	;PUT KB_SECOND_BUF IN KB_SECOND
	XMIT `HIGH KB_THIRD, ADDR_HIGH
	XMIT `LOW KB_THIRD, ADDR_LOW
	MOVE R11, 8, DATA0	;PUT SCAN CODE IN KB_THIRD
	RET

PLOT_CELL
;FIRST CALCULATE THE DISPLAY ADDRESS BY SETTING THE ADDRESS TO DISPLAY_CELL_X AND ADDIGN DISPLAY_CELL_Y * 32
	XMIT `HIGH DISPLAY_CELL_X, ADDR_HIGH
	XMIT `LOW DISPLAY_CELL_X, ADDR_LOW
	XMIT $00, R6
	MOVE DATA0, 8, R11
	XMIT `HIGH DISPLAY_CELL_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_CELL_Y, ADDR_LOW
	XMIT $00, R4
	XMIT $20, R5
	MOVE DATA0, 8, R3
	XMIT `HIGH MACC_8_16, AUX
	CALL MACC_8_16
	XMIT `HIGH DISPLAY_CELL_VALUE, ADDR_HIGH
	XMIT `LOW DISPLAY_CELL_VALUE, ADDR_LOW
	MOVE DATA0, 8, AUX
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	NZT AUX, PC_NB
	XMIT $00, IO0, 7
	XMIT $01, IO7, 1
	RET
PC_NB
	XMIT $0F, IO0, 4
	MOVE AUX, 3, IO4
	XMIT $01, IO7, 1
	RET

PLOT_ELEMENT
;FIRST CALCULATE CELL X POSITION AND STORE IN MACC RESULT
	XMIT `HIGH DISPLAY_ELEMENT_X, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_X, ADDR_LOW
	XMIT $00, R6
	MOVE DATA1, 7, R11
;THEN CALCULATE CELL Y POSITION AND MULTIPLY BY 32, ADD RESULT TO X POSITION
	XMIT `HIGH DISPLAY_ELEMENT_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_Y, ADDR_LOW
	XMIT $00, R4
	XMIT $20, R5
	MOVE DATA1, 7, R3
	XMIT `HIGH MACC_8_16, AUX
	CALL MACC_8_16	;R6 AND R11 NOW CONTAIN THE CELL ADDRESS
;FIGURE OUT WHICH ELEMENT NEEDS TO BE MODIFIED
	XMIT `HIGH DISPLAY_ELEMENT_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_Y, ADDR_LOW
	MOVE DATA0, 1, R5
	MOVE DATA0, 1, AUX
	ADD R5, AUX
	XMIT `HIGH DISPLAY_ELEMENT_X, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_X, ADDR_LOW
	XOR DATA0, 1, R5	;R5 NOW INDICATES WHICH ELEMENT NEEDS TO BE MODIFIED
;GET THE ELEMENT VALUE AND DETERMINE IF IT IS BLACK
	XMIT `HIGH DISPLAY_ELEMENT_VALUE, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_VALUE, ADDR_LOW
	MOVE DATA0, 8, R4	;R4 NOW CONTAINS THE ELEMENT VALUE
	MOVE DATA0, 8, AUX
;COPY CURRENT CELL STATE TO IV LATCH SO WE CAN MODIFY IT
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	MOVE IO0, 8, IO0
	XMIT $01, IO7, 1
	NZT AUX, PE_NB
;IF THE ELEMENT IS BLACK TURN IT OFF AND RETURN
	XEC PE_CLEAR (R5) [4]
	RET
PE_CLEAR
	XMIT $00, IO3, 1
	XMIT $00, IO2, 1
	XMIT $00, IO1, 1
	XMIT $00, IO0, 1
PE_NB
;IF THE ELEMENT IS NOT BLACK TURN IT ON AND SET THE CELL COLOR
	MOVE R4, 3, IO4
	XEC PE_SET (R5) [4]
	RET
PE_SET
	XMIT $01, IO3, 1
	XMIT $01, IO2, 1
	XMIT $01, IO1, 1
	XMIT $01, IO0, 1

	ORG $0300
MAIN	;L0
	XMIT `HIGH FRAME_COUNT, ADDR_HIGH
	XMIT `LOW FRAME_COUNT, ADDR_LOW
	XMIT $00, DATA0, 8
	XMIT `HIGH HEX_INC, AUX
	CALL HEX_INC	;03
	XMIT `HIGH INTERRUPT_CONTROL, ADDR_HIGH
	XMIT `LOW INTERRUPT_CONTROL, ADDR_LOW
	XMIT %0000 0101, IO0, 8
MAIN_LOOP
	XMIT `HIGH M_RING_0, AUX
	CALL M_RING_0
	JMP MAIN_LOOP	;DISABLE VSYNC POLLING FOR TESTING

M_RING_0	;L3
	XMIT `HIGH KB_UPDATE, AUX
	CALL KB_UPDATE
	XMIT `HIGH KB_FIRST, ADDR_HIGH
	XMIT `LOW KB_FIRST, ADDR_LOW
	MOVE DATA0, 8, R11
	NZT R11, MR0_HAS_CODE
	RET
MR0_HAS_CODE
; BIT ORDER: ENTER, SHIFT, UP, DOWN, LEFT, RIGHT
; MAKE CODES: 5A, 59, E0 75, E0 72, E0 6B, E0 74
; BREAK CODES: F0 5A, F0 59, E0 F0 75, E0 F0 72, E0 F0 6B, E0 F0 74
	XMIT $E0, AUX
	XOR R11, AUX
	NZT AUX, MR0_NOT_SPECIAL
; HANDLE SPECIAL CODES HERE
	XMIT `HIGH KB_SECOND, ADDR_HIGH
	XMIT `LOW KB_SECOND, ADDR_LOW
	MOVE DATA0, 8, R11
	XMIT $F0, AUX
	XOR R11, AUX
	NZT AUX, MR0_S_NOT_BREAK
; HANDLE SPECIAL BREAK CODES HERE
	XMIT `HIGH KB_THIRD, ADDR_HIGH
	XMIT `LOW KB_THIRD, ADDR_LOW
	MOVE DATA0, 8, R11
	XMIT `HIGH KEY_FLAGS, ADDR_HIGH
	XMIT `LOW KEY_FLAGS, ADDR_LOW
	MOVE DATA0, 8, DATA0	;GET CURRENT KEY STATES
	XMIT $75, AUX
	XOR R11, AUX
	NZT AUX, MR0_SB_NOT_UP
	XMIT $00, DATA3, 1	;CLEAR UP KEY
	RET
MR0_SB_NOT_UP
	XMIT $72, AUX
	XOR R11, AUX
	NZT AUX, MR0_SB_NOT_DOWN
	XMIT $00, DATA2, 1	;CLEAR DOWN KEY
	RET
MR0_SB_NOT_DOWN
	XMIT $6B, AUX
	XOR R11, AUX
	NZT AUX, MR0_SB_NOT_LEFT
	XMIT $00, DATA1, 1	;CLEAR LEFT KEY
	RET
MR0_SB_NOT_LEFT
	XMIT $74, AUX
	XOR R11, AUX
	NZT AUX, MR0_SB_NOT_RIGHT
	XMIT $00, DATA0, 1	;CLEAR RIGHT KEY
	RET
MR0_SB_NOT_RIGHT
	RET
MR0_S_NOT_BREAK
; HANDLE SPECIAL MAKE CODES HERE
	XMIT `HIGH KEY_FLAGS, ADDR_HIGH
	XMIT `LOW KEY_FLAGS, ADDR_LOW
	MOVE DATA0, 8, DATA0	;GET CURRENT KEY STATES
	XMIT $75, AUX,
	XOR R11, AUX
	NZT AUX, MR0_SM_NOT_UP
	XMIT $01, DATA3, 1	;SET UP KEY
	RET
MR0_SM_NOT_UP
	XMIT $72, AUX
	XOR R11, AUX
	NZT AUX, MR0_SM_NOT_DOWN
	XMIT $01, DATA2, 1	;SET DOWN KEY
	RET
MR0_SM_NOT_DOWN
	XMIT $6B, AUX
	XOR, R11, AUX
	NZT AUX, MR0_SM_NOT_LEFT
	XMIT $01, DATA1, 1	;SET LEFT KEY
	RET
MR0_SM_NOT_LEFT
	XMIT $74, AUX
	XOR, R11, AUX
	NZT AUX, MR0_SM_NOT_RIGHT
	XMIT $01, DATA0, 1	;SET RIGHT KEY
	RET
MR0_SM_NOT_RIGHT
	RET
MR0_NOT_SPECIAL
; HANDLE NORMAL CODES HERE
	XMIT $F0, AUX
	XOR R11, AUX
	NZT AUX, MR0_NS_NOT_BREAK
;HANDLE BREAK CODES HERE
	XMIT `HIGH KB_SECOND, ADDR_HIGH
	XMIT `LOW KB_SECOND, ADDR_LOW
	MOVE DATA0, 8, R11
	XMIT `HIGH KEY_FLAGS, ADDR_HIGH
	XMIT `LOW KEY_FLAGS, ADDR_LOW
	MOVE DATA0, 8, DATA0	;GET CURRENT KEY STATES
	XMIT $5A, AUX
	XOR R11, AUX
	NZT AUX, MR0_B_NOT_ENTER
	XMIT $00, DATA5, 1	;CLEAR ENTER KEY
	RET
MR0_B_NOT_ENTER
	XMIT $59, AUX
	XOR R11, AUX
	NZT AUX, MR0_B_NOT_SHIFT
	XMIT $00, DATA4, 1	;CLEAR SHIFT KEY
	RET
MR0_B_NOT_SHIFT
	RET
MR0_NS_NOT_BREAK
;HANDLE MAKE CODES HERE
	XMIT `HIGH KEY_FLAGS, ADDR_HIGH
	XMIT `LOW KEY_FLAGS, ADDR_LOW
	MOVE DATA0, 8, DATA0	;GET CURRENT KEY STATES
	XMIT $5A, AUX
	XOR R11, AUX
	NZT AUX, MR0_M_NOT_ENTER
	XMIT $01, DATA5, 1	;SET ENTER KEY
	RET
MR0_M_NOT_ENTER
	XMIT $59, AUX
	XOR R11, AUX
	NZT AUX, MR0_M_NOT_SHIFT
	XMIT $01, DATA4, 1	;SET SHIFT KEY
	RET
MR0_M_NOT_SHIFT
	RET

MR2_TEST
	XMIT `HIGH RND_BUILD_BYTE, AUX
	CALL RND_BUILD_BYTE
	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	;XMIT $20, R5
	XMIT $40, R5
	MOVE DATA0, 8, R4
	XMIT `HIGH DIV8, AUX
	CALL DIV8
	;XMIT `HIGH DISPLAY_CELL_X, ADDR_HIGH
	;XMIT `LOW DISPLAY_CELL_X, ADDR_LOW
	XMIT `HIGH DISPLAY_ELEMENT_X, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_X, ADDR_LOW
	MOVE R4, 8, DATA0

	XMIT `HIGH RND_BUILD_BYTE, AUX
	CALL RND_BUILD_BYTE
	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	;XMIT $10, R5
	XMIT $20, R5
	MOVE DATA0, 8, R4
	XMIT `HIGH DIV8, AUX
	CALL DIV8
	;XMIT `HIGH DISPLAY_CELL_Y, ADDR_HIGH
	;XMIT `LOW DISPLAY_CELL_Y, ADDR_LOW
	XMIT `HIGH DISPLAY_ELEMENT_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_Y, ADDR_LOW
	MOVE R4, 8, DATA0

	XMIT `HIGH RND_BUILD_BYTE, AUX
	CALL RND_BUILD_BYTE
	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	XMIT $09, R5
	MOVE DATA0, 8, R4
	XMIT `HIGH DIV8, AUX
	CALL DIV8
	;XMIT `HIGH DISPLAY_CELL_VALUE, ADDR_HIGH
	;XMIT `LOW DISPLAY_CELL_VALUE, ADDR_LOW
	XMIT `HIGH DISPLAY_ELEMENT_VALUE, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_VALUE, ADDR_LOW
	MOVE R4, 8, DATA0

	;XMIT `HIGH PLOT_CELL, AUX
	;CALL PLOT_CELL
	XMIT `HIGH PLOT_ELEMENT, AUX
	CALL PLOT_ELEMENT
	RET

;NOTE: LABELS ON ORG STATEMENTS CANNOT BE REFERENCED IN THE CODE! THESE DO NOT BELONG TO ANY SEGMENT AND WILL NOT BE FOUND.
STRINGS	ORG $0600
S_HEX
	XEC HEX_0 (R5) [16]	;CHARS 0 - F
	RET
HEX_0
	XMIT $30, R5
	XMIT $31, R5
	XMIT $32, R5
	XMIT $33, R5
	XMIT $34, R5
	XMIT $35, R5
	XMIT $36, R5
	XMIT $37, R5
	XMIT $38, R5
	XMIT $39, R5
	XMIT $41, R5
	XMIT $42, R5
	XMIT $43, R5
	XMIT $44, R5
	XMIT $45, R5
	XMIT $46, R5

S_SNAKE
	XEC SNAKE_0 (R5) [11]
	RET
SNAKE_0
	XMIT 'S', R3
	XMIT 'N', R3
	XMIT 'A', R3
	XMIT 'K', R3
	XMIT 'E', R3
	XMIT '\S', R3
	XMIT 'G', R3
	XMIT 'A', R3
	XMIT 'M', R3
	XMIT 'E', R3
	XMIT '\0', R3

S_SCORE
	XEC SCORE_0 (R5) [12]
	RET
SCORE_0
	XMIT 'Y', R3
	XMIT 'O', R3
	XMIT 'U', R3
	XMIT 'R', R3
	XMIT '\S', R3
	XMIT 'S', R3
	XMIT 'C', R3
	XMIT 'O', R3
	XMIT 'R', R3
	XMIT 'E', R3
	XMIT ':', R3
	XMIT '\S', R3
	XMIT '\0', R3

S_HIGH
	XEC HIGH_0 (R5) [12]
	RET
HIGH_0
	XMIT 'H', R3
	XMIT 'I', R3
	XMIT 'G', R3
	XMIT 'H', R3
	XMIT '\S', R3
	XMIT 'S', R3
	XMIT 'C', R3
	XMIT 'O', R3
	XMIT 'R', R3
	XMIT 'E', R3
	XMIT ':', R3
	XMIT '\S', R3
	XMIT '\0', R3

S_BEGIN
	XEC BEGIN_0 (R5) [27]
	RET
BEGIN_0
	XMIT 'P', R3
	XMIT 'R', R3
	XMIT 'E', R3
	XMIT 'S', R3
	XMIT 'S', R3
	XMIT '\S', R3
	XMIT 'R', R3
	XMIT 'I', R3
	XMIT 'G', R3
	XMIT 'H', R3
	XMIT 'T', R3
	XMIT '\S', R3
	XMIT 'S', R3
	XMIT 'H', R3
	XMIT 'I', R3
	XMIT 'F', R3
	XMIT 'T', R3
	XMIT '\S', R3
	XMIT 'T', R3
	XMIT 'O', R3
	XMIT '\S', R3
	XMIT 'B', R3
	XMIT 'E', R3
	XMIT 'G', R3
	XMIT 'I', R3
	XMIT 'N', R3
	XMIT '\0', R3

S_GAME_OVER
	XEC GAME_OVER_0 (R5) [10]
	RET
GAME_OVER_0
	XMIT 'G', R3
	XMIT 'A', R3
	XMIT 'M', R3
	XMIT 'E', R3
	XMIT '\S', R3
	XMIT 'O', R3
	XMIT 'V', R3
	XMIT 'E', R3
	XMIT 'R', R3
	XMIT '\0', R3

	ORG $0FFF	;PAD FILE TO 4K WORDS
	JMP INIT