;                     /\         /\__
;                   // \       (  0 )_____/\            __
;                  // \ \     (vv          o|          /^v\
;                //    \ \   (vvvv  ___-----^        /^^/\vv\
;              //  /     \ \ |vvvvv/               /^^/    \v\
;             //  /       (\\/vvvv/              /^^/       \v\
;            //  /  /  \ (  /vvvv/              /^^/---(     \v\
;           //  /  /    \( /vvvv/----(O        /^^/           \v\
;          //  /  /  \  (/vvvv/               /^^/             \v|
;        //  /  /    \( vvvv/                /^^/               ||
;       //  /  /    (  vvvv/                 |^^|              //
;      //  / /    (  |vvvv|                  /^^/            //
;     //  / /   (    \vvvvv\          )-----/^^/           //
;    // / / (          \vvvvv\            /^^^/          //
;   /// /(               \vvvvv\        /^^^^/          //
;  ///(              )-----\vvvvv\    /^^^^/-----(      \\
; //(                        \vvvvv\/^^^^/               \\
;/(                            \vvvv^^^/                 //
;                                \vv^/         /        //
;                                             /<______//
;                                            <<<------/
;                                             \<
;                                              \
;**************************************************
;* RIPTIDE_SNAKE_GAME.ASM     SOURCE FILE         *
;* Copyright (C) 2021 Esteban Looser-Rojas.       *
;* Contains snake game for the RIPTIDE-III        *
;* processor validation platform.                 *
;**************************************************

; REMEMBER: PROGRAM MEMORY IS WORD ADDRESSABLE WHILE DATA MEMORY IS BYTE ADDRESSABLE!
; THE TWO MEMORY SPACES ARE SHARED THROUGH THE CACHE CONTROLLERS, BOTH CACHES MUST BE FLUSHED FOR CHANGES TO THE DATA SPACE TO SHOW UP IN THE PROGRAM SPACE.

; IN SEMIGRAPHICS 4 THE DISPLAY HAS 32 * 16 CELLS AND 64 * 32 ELEMENTS.

; R15 IS RESERVED FOR SAVING ADDR_HIGH IN INTERRUPT HANDLERS, AND R16 IS RESERVED FOR ADDR_LOW

INCLUDE "RIPTIDE-III.INC"

;VARIABLES
DUMP_START_LOW		EQU $F000
DUMP_START_HIGH		EQU $F001
DUMP_END_LOW		EQU $F002
DUMP_END_HIGH		EQU $F003

DISPLAY_COUNT_L	EQU $F004	;UNUSED
DISPLAY_COUNT_H	EQU $F005	;UNUSED

DISPLAY_CELL_X	EQU $F006
DISPLAY_CELL_Y	EQU $F007
DISPLAY_CELL_VALUE	EQU $F008
DISPLAY_ELEMENT_X	EQU $F009
DISPLAY_ELEMENT_Y	EQU $F00A
DISPLAY_ELEMENT_VALUE	EQU $F00B
DISPLAY_CURSOR_X	EQU $F00C
DISPLAY_CURSOR_Y	EQU $F00D

PREV_VSYNC	EQU $F00E	;UNUSED
PREV_HSYNC	EQU $F00F	;UNUSED
FRAME_COUNT	EQU $F010

RND_L	EQU $F011
RND_H	EQU $F012

HEX_BUF_L	EQU $F013
HEX_BUF_H	EQU $F014

SNAKE_STATE	EQU $F015
SNAKE_SPEED	EQU $F016	;FRAMES PER GAME UPDATE

STR_BUF	EQU $F020
STR_BUF_END	EQU $F050
STR_BUF_OFFSET	EQU $F051

KB_STATE	EQU $F052
KB_FIRST_BUF	EQU $F053
KB_SECOND_BUF	EQU $F054
KB_FIRST	EQU $F055
KB_SECOND	EQU $F056
KB_THIRD	EQU $F057

KEY_FLAGS	EQU $F058
;	BIT 0: RIGHT ARROW
;	BIT 1: LEFT ARROW
;	BIT 2: DOWN ARROW
;	BIT 3: UP ARROW
;	BIT 4: SHIFT KEY
;	BIT 5: ENTER KEY

SCORE	EQU $F059
HIGH_SCORE	EQU $F05A
PLAYFIELD	EQU $F05B
PLAYFIELD_END	EQU $F85B
HEAD_X	EQU $F85B
HEAD_Y	EQU $F85C
TAIL_X	EQU $F85D
TAIL_Y	EQU $F85E
HEAD_DIRECTION	EQU $F85F
TAIL_DIRECTION	EQU $F860
TARGET_X	EQU $F863
TARGET_Y	EQU $F864

AUX_SAVE_LOC	EQU $F865
R1_SAVE_LOC		EQU $F866
R2_SAVE_LOC		EQU $F867
R3_SAVE_LOC		EQU $F868
R4_SAVE_LOC		EQU $F869
R5_SAVE_LOC		EQU $F86A
R6_SAVE_LOC		EQU $F86B
ADDR_HIGH_SAVE_LOC	EQU $F86C	;UNUSED
OVF_SAVE_LOC	EQU $F86D
R11_SAVE_LOC	EQU $F86E
R12_SAVE_LOC	EQU $F86F
R13_SAVE_LOC	EQU $F870
R14_SAVE_LOC	EQU $F871
ADDR_LOW_SAVE_LOC	EQU $F872	;UNUSED

;CONSTANTS
S_KB_READ_FIRST		EQU $00
S_KB_READ_SECOND	EQU $01
S_KB_READ_THIRD		EQU $02
S_KB_WAIT_BAT		EQU $03
S_KB_SET_LED		EQU $04

S_SNAKE_HOME	EQU $00
S_SNAKE_GAME_OVER	EQU $01
S_SNAKE_PAUSE	EQU $02
S_SNAKE_WAIT	EQU $03
S_SNAKE_RESET	EQU $04
S_SNAKE_RUN	EQU $05

SG4_BLACK	EQU $00
SG4_YELLOW	EQU $01
SG4_BLUE	EQU $02
SG4_RED		EQU $03
SG4_BUFF	EQU $04
SG4_CYAN	EQU $05
SG4_MAGENTA	EQU $06
SG4_ORANGE	EQU $07
SG4_GREEN	EQU $08

	ORG 0
	JMP INT_RESET
	RET	;INT1
	JMP INT_VSYNC
	RET	;INT3
	RET	;INT4
	jmp int_kb
	jmp int_timer
	RET	;INT7

INT_RESET
	XMIT `HIGH INTERRUPT_STATUS, ADDR_HIGH
	XMIT `LOW INTERRUPT_STATUS, ADDR_LOW
	XMIT $00, IO0, 0
	XMIT `HIGH INTERRUPT_CONTROL, ADDR_HIGH
	XMIT `LOW INTERRUPT_CONTROL, ADDR_LOW
	XMIT %0000 0001, IO0, 0
	JMP INIT

INT_VSYNC
; SAVE ALL REGISTERS
	MOVE ADDR_HIGH, R15
	MOVE ADDR_LOW, R16
	XMIT `HIGH AUX_SAVE_LOC, ADDR_HIGH
	XMIT `LOW AUX_SAVE_LOC, ADDR_LOW
	MOVE AUX, DATA0
	XMIT `LOW R1_SAVE_LOC, ADDR_LOW
	MOVE R1, DATA0
	XMIT `LOW R2_SAVE_LOC, ADDR_LOW
	MOVE R2, DATA0
	XMIT `LOW R3_SAVE_LOC, ADDR_LOW
	MOVE R3, DATA0
	XMIT `LOW R4_SAVE_LOC, ADDR_LOW
	MOVE R4, DATA0
	XMIT `LOW R5_SAVE_LOC, ADDR_LOW
	MOVE R5, DATA0
	XMIT `LOW R6_SAVE_LOC, ADDR_LOW
	MOVE R6, DATA0
	XMIT `LOW OVF_SAVE_LOC, ADDR_LOW
	MOVE OVF, DATA0
	XMIT `LOW R11_SAVE_LOC, ADDR_LOW
	MOVE R11, DATA0
	XMIT `LOW R12_SAVE_LOC, ADDR_LOW
	MOVE R12, DATA0
	XMIT `LOW R13_SAVE_LOC, ADDR_LOW
	MOVE R13, DATA0
	XMIT `LOW R14_SAVE_LOC, ADDR_LOW
	MOVE R14, DATA0
; RUN VSYNC CODE
	XMIT `HIGH SNAKE_UPDATE, AUX
	CALL SNAKE_UPDATE
	XMIT `HIGH HEX_INC, AUX
	CALL HEX_INC	;04

; RESTORE REGISTERS
	XMIT `HIGH R1_SAVE_LOC, ADDR_HIGH
	XMIT `LOW R1_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R1
	XMIT `LOW R2_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R2
	XMIT `LOW R3_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R3
	XMIT `LOW R4_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R4
	XMIT `LOW R5_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R5
	XMIT `LOW R6_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R6
	XMIT `LOW OVF_SAVE_LOC, ADDR_LOW
	XMIT $FF, AUX
	ADD DATA0, 8, AUX	;OVF IS NOT DIRECTLY WRITABLE
	XMIT `LOW R11_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R11
	XMIT `LOW R12_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R12
	XMIT `LOW R13_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R13
	XMIT `LOW R14_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R14
; CLEAR VSYNC INTERRUPT FLAG
	XMIT `HIGH INTERRUPT_STATUS, ADDR_HIGH
	XMIT `LOW INTERRUPT_STATUS, ADDR_LOW
	XMIT %1111 1011, AUX
	AND IO0, 8, IO0

	XMIT `HIGH AUX_SAVE_LOC, ADDR_HIGH
	XMIT `LOW AUX_SAVE_LOC, ADDR_LOW
	MOVE DATA0, AUX	;AUX MUST BE RESTORED AFTER RESTORING OVF
	MOVE R15, ADDR_HIGH
	MOVE R16, ADDR_LOW
	RET

int_kb
; SAVE ALL REGISTERS
	MOVE ADDR_HIGH, R15
	MOVE ADDR_LOW, R16
	XMIT `HIGH AUX_SAVE_LOC, ADDR_HIGH
	XMIT `LOW AUX_SAVE_LOC, ADDR_LOW
	MOVE AUX, DATA0
	XMIT `LOW R1_SAVE_LOC, ADDR_LOW
	MOVE R1, DATA0
	XMIT `LOW R2_SAVE_LOC, ADDR_LOW
	MOVE R2, DATA0
	XMIT `LOW R3_SAVE_LOC, ADDR_LOW
	MOVE R3, DATA0
	XMIT `LOW R4_SAVE_LOC, ADDR_LOW
	MOVE R4, DATA0
	XMIT `LOW R5_SAVE_LOC, ADDR_LOW
	MOVE R5, DATA0
	XMIT `LOW R6_SAVE_LOC, ADDR_LOW
	MOVE R6, DATA0
	XMIT `LOW OVF_SAVE_LOC, ADDR_LOW
	MOVE OVF, DATA0
	XMIT `LOW R11_SAVE_LOC, ADDR_LOW
	MOVE R11, DATA0
	XMIT `LOW R12_SAVE_LOC, ADDR_LOW
	MOVE R12, DATA0
	XMIT `LOW R13_SAVE_LOC, ADDR_LOW
	MOVE R13, DATA0
	XMIT `LOW R14_SAVE_LOC, ADDR_LOW
	MOVE R14, DATA0

; RUN KB CODE
	XMIT `HIGH KB_UPDATE, AUX
	CALL KB_UPDATE

	XMIT `HIGH KB_PROCESS, AUX
	CALL KB_PROCESS

	; CHECK KEYS TO SET DIRECTION
	XMIT `HIGH KEY_FLAGS, ADDR_HIGH
	XMIT `LOW KEY_FLAGS, ADDR_LOW
	XMIT $01, AUX
	XMIT $01, R1
; CHECK UP KEY
	AND DATA3, 1, R11
	NZT R11, MR2_UPDATE_DIRECTION
	ADD R1, R1
; CHECK DOWN KEY
	AND DATA2, 1, R11
	NZT R11, MR2_UPDATE_DIRECTION
	ADD R1, R1
; CHECK LEFT KEY
	AND DATA1, 1, R11
	NZT R11, MR2_UPDATE_DIRECTION
	ADD R1, R1
; CHECK RIGHT KEY
	AND DATA0, 1, R11
	NZT R11, MR2_UPDATE_DIRECTION
	JMP ik_done
MR2_UPDATE_DIRECTION
	XMIT `HIGH HEAD_DIRECTION, ADDR_HIGH
	XMIT `LOW HEAD_DIRECTION, ADDR_LOW
	MOVE R1, 8, DATA0
ik_done
	XMIT `HIGH HEX_BUF_H, ADDR_HIGH
	XMIT `LOW HEX_BUF_H, ADDR_LOW
	XMIT $00, DATA0, 8	;CLEAR HEX HIGH
	XMIT `HIGH HEX_BUF_L, ADDR_HIGH
	XMIT `LOW HEX_BUF_L, ADDR_LOW
	XMIT $00, DATA0, 8	;CLEAR HEX LOW

; RESTORE REGISTERS
	XMIT `HIGH R1_SAVE_LOC, ADDR_HIGH
	XMIT `LOW R1_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R1
	XMIT `LOW R2_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R2
	XMIT `LOW R3_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R3
	XMIT `LOW R4_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R4
	XMIT `LOW R5_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R5
	XMIT `LOW R6_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R6
	XMIT `LOW OVF_SAVE_LOC, ADDR_LOW
	XMIT $FF, AUX
	ADD DATA0, 8, AUX	;OVF IS NOT DIRECTLY WRITABLE
	XMIT `LOW R11_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R11
	XMIT `LOW R12_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R12
	XMIT `LOW R13_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R13
	XMIT `LOW R14_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R14

; CLEAR KB INTERRUPT FLAG
	XMIT `HIGH INTERRUPT_STATUS, ADDR_HIGH
	XMIT `LOW INTERRUPT_STATUS, ADDR_LOW
	XMIT %1101 1111, AUX
	move aux, 8, IO0

	XMIT `HIGH AUX_SAVE_LOC, ADDR_HIGH
	XMIT `LOW AUX_SAVE_LOC, ADDR_LOW
	MOVE DATA0, AUX	;AUX MUST BE RESTORED AFTER RESTORING OVF
	MOVE R15, ADDR_HIGH
	MOVE R16, ADDR_LOW
	RET


int_timer
; SAVE ALL REGISTERS
	MOVE ADDR_HIGH, R15
	MOVE ADDR_LOW, R16
	XMIT `HIGH AUX_SAVE_LOC, ADDR_HIGH
	XMIT `LOW AUX_SAVE_LOC, ADDR_LOW
	MOVE AUX, DATA0
	XMIT `LOW R1_SAVE_LOC, ADDR_LOW
	MOVE R1, DATA0
	XMIT `LOW R2_SAVE_LOC, ADDR_LOW
	MOVE R2, DATA0
	XMIT `LOW R3_SAVE_LOC, ADDR_LOW
	MOVE R3, DATA0
	XMIT `LOW R4_SAVE_LOC, ADDR_LOW
	MOVE R4, DATA0
	XMIT `LOW R5_SAVE_LOC, ADDR_LOW
	MOVE R5, DATA0
	XMIT `LOW R6_SAVE_LOC, ADDR_LOW
	MOVE R6, DATA0
	XMIT `LOW OVF_SAVE_LOC, ADDR_LOW
	MOVE OVF, DATA0
	XMIT `LOW R11_SAVE_LOC, ADDR_LOW
	MOVE R11, DATA0
	XMIT `LOW R12_SAVE_LOC, ADDR_LOW
	MOVE R12, DATA0
	XMIT `LOW R13_SAVE_LOC, ADDR_LOW
	MOVE R13, DATA0
	XMIT `LOW R14_SAVE_LOC, ADDR_LOW
	MOVE R14, DATA0
; RUN TIMER CODE
	XMIT `HIGH SNAKE_UPDATE, AUX
	CALL SNAKE_UPDATE
	XMIT `HIGH HEX_INC, AUX
	CALL HEX_INC	;04

; RESTORE REGISTERS
	XMIT `HIGH R1_SAVE_LOC, ADDR_HIGH
	XMIT `LOW R1_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R1
	XMIT `LOW R2_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R2
	XMIT `LOW R3_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R3
	XMIT `LOW R4_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R4
	XMIT `LOW R5_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R5
	XMIT `LOW R6_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R6
	XMIT `LOW OVF_SAVE_LOC, ADDR_LOW
	XMIT $FF, AUX
	ADD DATA0, 8, AUX	;OVF IS NOT DIRECTLY WRITABLE
	XMIT `LOW R11_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R11
	XMIT `LOW R12_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R12
	XMIT `LOW R13_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R13
	XMIT `LOW R14_SAVE_LOC, ADDR_LOW
	MOVE DATA0, R14
;reset the timer
	xmit `high timer_count_2, addr_high
	xmit `low timer_count_2, addr_low
	xmit $06, aux
	move aux, 8, io0
	xmit `high timer_count_1, addr_high
	xmit `low timer_count_1, addr_low
	xmit $1A, aux
	move aux, 8, io0
	xmit `high timer_count_0, addr_high
	xmit `low timer_count_0, addr_low
	xmit $80, aux
	move aux, 8, io0

; CLEAR TIMER INTERRUPT FLAG
	XMIT `HIGH INTERRUPT_STATUS, ADDR_HIGH
	XMIT `LOW INTERRUPT_STATUS, ADDR_LOW
	XMIT %1011 1111, AUX
	move aux, 8, IO0

	XMIT `HIGH AUX_SAVE_LOC, ADDR_HIGH
	XMIT `LOW AUX_SAVE_LOC, ADDR_LOW
	MOVE DATA0, AUX	;AUX MUST BE RESTORED AFTER RESTORING OVF
	MOVE R15, ADDR_HIGH
	MOVE R16, ADDR_LOW
	RET


	org $100
SNAKE_UPDATE
	XMIT `HIGH SNAKE_STATE, ADDR_HIGH
	XMIT `LOW SNAKE_STATE, ADDR_LOW
	MOVE DATA0, 8, AUX
	XEC VS_SWITCH (AUX) [6]
VS_SWITCH
	JMP SNAKE_HOME
	JMP SNAKE_GAME_OVER
	JMP SNAKE_PAUSE
	JMP SNAKE_WAIT
	JMP SNAKE_RESET
	JMP SNAKE_RUN

	ORG $0200
INIT
	XMIT $00, AUX
	XMIT $00, R1
	XMIT $00, R2

	XMIT `HIGH MSC_D_CONTROL, ADDR_HIGH
	XMIT `LOW MSC_D_CONTROL, ADDR_LOW
	XMIT $08, IO0, 8	;ENABLE DATA CACHE CONTROL

	XMIT `LOW MSC_D_PAGE, ADDR_LOW
	XMIT $02, IO0, 8	;SWITCH TO DATA PAGE 2

	XMIT `LOW MSC_D_CONTROL, ADDR_LOW
	XMIT $01, IO0, 8	;RESET DATA CACHE AND DISABLE CONTROL

	XMIT $00, R3
	XMIT $00, R4
	XMIT $00, R5
	XMIT $00, R6
	XMIT $00, R11	;INITIALIZE REGISTERS
	XMIT $00, R12
	XMIT $00, R13
	XMIT $00, R14
	XMIT $00, R15
	XMIT $00, R16
	MOVE DATA0, 8, AUX	;HOLD UNTIL CACHE RESET IS DONE

	XMIT `HIGH HEX_BUF_H, ADDR_HIGH
	XMIT `LOW HEX_BUF_H, ADDR_LOW
	XMIT $00, DATA0, 8	;CLEAR HEX HIGH
	XMIT `HIGH HEX_BUF_L, ADDR_HIGH
	XMIT `LOW HEX_BUF_L, ADDR_LOW
	XMIT $00, DATA0, 8	;CLEAR HEX LOW

	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	XMIT $00, DATA0, 8
	XMIT `HIGH RND_H, ADDR_HIGH
	XMIT `LOW RND_H, ADDR_LOW
	XMIT $00, DATA0, 8
;INITIALIZE KB FSM
	XMIT `HIGH KB_STATE, ADDR_HIGH
	XMIT `LOW KB_STATE, ADDR_LOW
	XMIT S_KB_WAIT_BAT, DATA0, 8
;RESET THE KEYBOARD
	XMIT `HIGH KB_DATA, ADDR_HIGH
	XMIT `LOW KB_DATA, ADDR_LOW
	XMIT $FF, AUX		;$FF IS THE KEYBOARD RESET COMMAND
	MOVE AUX, 8, IO0

	XMIT `HIGH KEY_FLAGS, ADDR_HIGH
	XMIT `LOW KEY_FLAGS, ADDR_LOW
	XMIT $00, DATA0, 8

	XMIT `HIGH HEX_INC, AUX
	CALL HEX_INC	;01

	;INITIALIZE DISPLAY IN SEMI-GRAPHICS 4 MODE
	XMIT $8F, R3
	XMIT `HIGH DISPLAY_INIT_SG4, AUX
	CALL DISPLAY_INIT_SG4

	XMIT `HIGH HEX_INC, AUX
	CALL HEX_INC	;02

	JMP MAIN

HEX_INC
	XMIT `HIGH HEX_BUF_L, ADDR_HIGH
	XMIT `LOW HEX_BUF_L, ADDR_LOW
	XMIT $01, AUX
	ADD DATA0, 8, AUX
	MOVE AUX, 8, DATA0
	XMIT `HIGH HEX_LOW, ADDR_HIGH
	XMIT `LOW HEX_LOW, ADDR_LOW
	MOVE AUX, 8, IO0
	XMIT `HIGH HEX_BUF_H, ADDR_HIGH
	XMIT `LOW HEX_BUF_H, ADDR_LOW
	MOVE OVF, AUX
	ADD DATA0, 8, AUX
	MOVE AUX, 8, DATA0
	XMIT `HIGH HEX_HIGH, ADDR_HIGH
	XMIT `LOW HEX_HIGH, ADDR_LOW
	MOVE AUX, 8, IO0
	RET

BIG_DUMP
; LOAD END ADDRESS AND MAKE IT NEGATIVE
	XMIT `HIGH DUMP_END_HIGH, IVL
	XMIT `LOW DUMP_END_HIGH, IVR
	MOVE DATA0, 8, R1

	XMIT `HIGH DUMP_END_LOW, IVL
	XMIT `LOW DUMP_END_LOW, IVR
	MOVE DATA0, 8, R2

	XMIT $FF, AUX
	XOR R1, R1
	XOR R2, R2

	XMIT $01, AUX	;WE MAKE THE HIGH AND LOW PARTS NEGATIVE, NOT THE WHOLE THING.
	ADD R2, R2		;THIS IS BECAUSE WE COMPARE IT BY PARTS.
	ADD R1, R1
; LOAD START ADDRESS
	XMIT `HIGH DUMP_START_HIGH, IVL
	XMIT `LOW DUMP_START_HIGH, IVR
	MOVE DATA0, 8, R5

	XMIT `HIGH DUMP_START_LOW, IVL
	XMIT `LOW DUMP_START_LOW, IVR
	MOVE DATA0, 8, R6
BD_LOOP
; READ DATA FROM MEMORY
	MOVE R5, IVL
	MOVE R6, IVR
	MOVE DATA0, 8, R4
; CHECK THAT UART IS READY
	XMIT `HIGH UART_STATUS, ADDR_HIGH
	XMIT `LOW UART_STATUS, ADDR_LOW
BD_WAIT
	XMIT $01, AUX
	MOVE IO2, 1, R3
	XOR R3, R3
	NZT R3, BD_WAIT
	XMIT `HIGH UART_DATA, ADDR_HIGH
	XMIT `LOW UART_DATA, ADDR_LOW
	MOVE R4, 8, IO0
; ADD 1 TO ADDRESS
	ADD R6, R6
	MOVE OVF, AUX
	ADD R5, R5
; COMPARE HIGH ADDRESS
	MOVE R5, AUX
	ADD R1, R3
	NZT R3, BD_LOOP
; COMPARE LOW ADDRESS
	MOVE R6, AUX
	ADD R2, R3
	NZT R3, BD_LOOP
	RET

SNAKE_DUMP
; CONFIGURE DUMP
	XMIT `HIGH DUMP_END_HIGH, ADDR_HIGH
	XMIT `LOW DUMP_END_HIGH, ADDR_LOW
	XMIT `HIGH PLAYFIELD_END, AUX
	MOVE AUX, DATA0
	XMIT `HIGH DUMP_END_LOW, ADDR_HIGH
	XMIT `LOW DUMP_END_LOW, ADDR_LOW
	XMIT `LOW PLAYFIELD_END, AUX
	MOVE AUX, DATA0	;DUMP END VARS NOW CONTAIN PLAYFIELD_END
	XMIT `HIGH DUMP_START_HIGH, IVL
	XMIT `LOW DUMP_START_HIGH, IVR
	XMIT `HIGH PLAYFIELD, AUX
	MOVE AUX, DATA0
	XMIT `HIGH DUMP_START_LOW, IVL
	XMIT `LOW DUMP_START_LOW, IVR
	XMIT `LOW PLAYFIELD, AUX
	MOVE AUX, DATA0	;DUMP START VARS NOW CONTAIN $0000
; CALL BIG DUMP
	XMIT `HIGH BIG_DUMP, AUX
	CALL BIG_DUMP
	RET

SERIAL_GET_BYTE
; CHECK THAT UART IS READY
	XMIT `HIGH UART_STATUS, ADDR_HIGH
	XMIT `LOW UART_STATUS, ADDR_LOW
SGB_WAIT
	XMIT $01, AUX
	MOVE IO3, 1, R11 	;READ RX DONE BIT
	XOR R11, R11 			;INVERT RX DONE BIT
	NZT R11, SGB_WAIT	;IF TX NOT READY KEEP WAITING
	XMIT `LOW UART_DATA, ADDR_LOW
	MOVE IO0, 8, R11
	RET

SERIAL_SEND_BYTE
; CHECK THAT UART IS READY
	XMIT `HIGH UART_STATUS, ADDR_HIGH
	XMIT `LOW UART_STATUS, ADDR_LOW
SSB_WAIT
	XMIT $01, AUX
	MOVE IO2, 1, R6
	XOR R6, R6
	NZT R6, SSB_WAIT
	XMIT `LOW UART_DATA, ADDR_LOW
	MOVE R11, 8, IO0
	RET

DISPLAY_INIT_SG4
;SET ALL CHARS TO 0X8F
;32 * 16 = 512 CHARS
	XMIT $00, R1	;LOW COUNTER
	XMIT $00, R2	;HIGH COUNTER
	XMIT $01, AUX	;IMPLICIT OPERAND FOR INCREMENTS
DI_LOOP
	MOVE R2, IVL
	MOVE R1, IVR
	MOVE R3, 8, IO0
	ADD R1, R1
	NZT R1, DI_LOOP
	NZT R2, DI_DONE
	ADD R2, R2
	JMP DI_LOOP
DI_DONE
	RET

BYTE_TO_HEX
	XMIT $0F, AUX
	AND R11, R5	;GET LOW NIBBLE IN R5
	XMIT `HIGH S_HEX, AUX
	CALL S_HEX
	MOVE R5, R6	;STORE LOW CHAR IN R6
	XMIT $0F, AUX
	AND R11(4), R5	;GET HIGH NIBBLE IN R5
	XMIT `HIGH S_HEX, AUX
	CALL S_HEX
	MOVE R5, R11	;STORE HIGH CHAR IN R11
	RET

RND_GET_WORD
	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	XMIT $01, AUX
	XOR DATA0, 1, AUX
	XOR DATA7, 1, AUX	;COMPUTE NEW MSB AND PUT IT IN AUX
	XMIT `HIGH RND_H, ADDR_HIGH
	XMIT `LOW RND_H, ADDR_LOW
	MOVE DATA0, 1, R11	;STORE LSB OF RND_H IN R11
	MOVE DATA1, 7, DATA0	;RIGHT SHIFT RND_H
	MOVE AUX, 1, DATA7	;STORE NEW MSB IN RND_H
	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	MOVE DATA1, 7, DATA0	;RIGHT SHIFT RND_L
	MOVE R11, 1, DATA7	;STORE LSB OF RND_H IN RND_L
	RET

RND_BUILD_BYTE
	XMIT $08, R6
	JMP RND_BUILD_LOOP
RND_BUILD_WORD
	XMIT $10, R6
RND_BUILD_LOOP
	XMIT `HIGH RND_GET_WORD, AUX
	CALL RND_GET_WORD
	XMIT $FF, AUX
	ADD R6, R6
	NZT R6, RND_BUILD_LOOP
	RET

TEMP EQU R3
NUMERATOR EQU R4
DENOMINATOR EQU R5
INDEX EQU R6
RESULT EQU R11

DIV8
	NZT DENOMINATOR, DIV8_NZ
	RET	;IF DENOMINATOR IS ZERO RETURN
DIV8_NZ
	XMIT $00, RESULT
	XMIT $01, INDEX	;INITIALIZE RESULT AND INDEX
SHIFT_IT8
	XMIT $80, AUX
	AND DENOMINATOR, AUX
	NZT AUX, DIV8LOOP	;IF MSB OF DENOMINATOR IS SET GOTO DIV8LOOP
	MOVE INDEX, AUX
	ADD INDEX, INDEX
	MOVE DENOMINATOR, AUX
	ADD DENOMINATOR, DENOMINATOR	;LEFT-SHIFT DENOMINATOR AND INDEX
	JMP SHIFT_IT8
DIV8LOOP
	XMIT $FF, AUX
	XOR DENOMINATOR, TEMP
	XMIT $01, AUX
	ADD TEMP, TEMP	;MAKE DENOMINATOR NEGATIVE AND STORE IT IN TEMP
	MOVE NUMERATOR, AUX
	ADD TEMP, TEMP	;SUBTRACT DENOMINATOR FROM NUMERATOR AND STORE RESULT IN TEMP
	XMIT $01, AUX
	XOR OVF, AUX	;FLIP CARRY BIT
	NZT AUX, FINAL8	;IF RESULT IS NEGATIVE GOTO FINAL8
	MOVE TEMP, NUMERATOR	;MAKE THE RESULT THE NEW NUMERATOR
	MOVE INDEX, AUX
	ADD RESULT, RESULT	;ADD INDEX TO THE RESULT
FINAL8
	XMIT $7F, AUX
	AND DENOMINATOR(1), DENOMINATOR
	AND INDEX(1), INDEX
	NZT INDEX, DIV8LOOP
	RET

MUL_IN_A EQU R3
MUL_IN_B_H EQU R4
MUL_IN_B_L EQU R5
MUL_OUT_H EQU R6
MUL_OUT_L EQU R11

MUL_8_16
	XMIT $00, MUL_OUT_H
	XMIT $00, MUL_OUT_L
MACC_8_16
	XMIT $01, AUX
	AND MUL_IN_A, AUX	;CHECK IF LSB OF IN_A IS SET
	NZT AUX, MACC_8_16_ADD	;IF IT IS ADD IN_B TO RESULT
;THE FOLLOWING CODE IS DUPLICATED FOR PERFORMANCE REASONS
	XMIT $7F, AUX
	AND MUL_IN_A(1), MUL_IN_A	;RIGHT SHIFT IN_A
	MOVE MUL_IN_B_H, AUX
	ADD MUL_IN_B_H, MUL_IN_B_H
	MOVE MUL_IN_B_L, AUX
	ADD MUL_IN_B_L, MUL_IN_B_L
	MOVE OVF, AUX
	ADD MUL_IN_B_H, MUL_IN_B_H	;LEFT SHIFT IN_B
	NZT MUL_IN_A, MACC_8_16
	RET
MACC_8_16_ADD
	MOVE MUL_IN_B_H, AUX
	ADD MUL_OUT_H, MUL_OUT_H
	MOVE MUL_IN_B_L, AUX
	ADD MUL_OUT_L, MUL_OUT_L
	MOVE OVF, AUX
	ADD MUL_OUT_H, MUL_OUT_H	;ADD MUL_IN_B TO MUL_OUT
;THE FOLLOWING CODE IS DUPLICATED FOR PERFORMANCE REASONS
	XMIT $7F, AUX
	AND MUL_IN_A(1), MUL_IN_A	;RIGHT SHIFT IN_A
	MOVE MUL_IN_B_H, AUX
	ADD MUL_IN_B_H, MUL_IN_B_H
	MOVE MUL_IN_B_L, AUX
	ADD MUL_IN_B_L, MUL_IN_B_L
	MOVE OVF, AUX
	ADD MUL_IN_B_H, MUL_IN_B_H	;LEFT SHIFT IN_B
	NZT MUL_IN_A, MACC_8_16
	RET

	ORG $0300
KB_UPDATE
; CHECK THAT KB HOST IS READY
	XMIT `HIGH KB_STATUS, ADDR_HIGH
	XMIT `LOW KB_STATUS, ADDR_LOW	;KB STATUS REGISTER ADDRESS
	MOVE IO3, 1, R11	;READ RX DONE BIT
	NZT R11, KU_HAS_DATA	;IF READY PROCESS THE SCAN CODE
;ELSE
	XMIT `HIGH KB_FIRST, ADDR_HIGH
	XMIT `LOW KB_FIRST, ADDR_LOW
	XMIT $00, DATA0, 8	;CLEAR KB_FIRST
	XMIT `HIGH KB_SECOND, ADDR_HIGH
	XMIT `LOW KB_SECOND, ADDR_LOW
	XMIT $00, DATA0, 8	;CLEAR KB_SECOND
	XMIT `HIGH KB_THIRD, ADDR_HIGH
	XMIT `LOW KB_THIRD, ADDR_LOW
	XMIT $00, DATA0, 8	;CLEAR KB_THIRD
	RET
KU_HAS_DATA
	XMIT `HIGH KB_DATA, ADDR_HIGH
	XMIT `LOW KB_DATA, ADDR_LOW
	MOVE IO0, 8, R11	;PUT SCAN CODE IN R11

	XMIT `HIGH KB_STATE, ADDR_HIGH
	XMIT `LOW KB_STATE, ADDR_LOW
	MOVE DATA0, 8, R6	;PUT STATE IN R6
	XEC KU_SWITCH (R6) [5]
KU_SWITCH
	JMP KU_PROCESS_FIRST
	JMP KU_PROCESS_SECOND
	JMP KU_PROCESS_THIRD
	JMP KU_WAIT_BAT
	JMP KU_SET_LED
KU_PROCESS_FIRST
	XMIT $E0, AUX
	XOR R11, R5
	NZT R5, KU_PF_IF2
	JMP KU_PF_FETCH	;IF SCAN CODE IS $E0 FETCH MORE BYTES
KU_PF_IF2	;ELSE CHECK IF SCAN CODE IS $F0
	XMIT $F0, AUX
	XOR R11, R5
	NZT R5, KU_PF_ELSE	;IF SCAN CODE NOT $E0 OR $F0 OUTPUT SINGLE BYTE CODE
KU_PF_FETCH	;IF SCAN CODE IS $E0 OR $F0 FETCH MORE BYTES
	XMIT `HIGH KB_STATE, ADDR_HIGH
	XMIT `LOW KB_STATE, ADDR_LOW
	XMIT S_KB_READ_SECOND, DATA0, 8	;SET STATE TO S_KB_READ_SECOND
	XMIT `HIGH KB_FIRST_BUF, ADDR_HIGH
	XMIT `LOW KB_FIRST_BUF, ADDR_LOW
	MOVE R11, 8, DATA0	;PUT SCAN CODE IN KB_FIRST_BUF
	RET
KU_PF_ELSE
	XMIT `HIGH KB_FIRST, ADDR_HIGH
	XMIT `LOW KB_FIRST, ADDR_LOW
	MOVE R11, 8, DATA0	;PUT SCAN CODE IN KB_FIRST
	RET
KU_PROCESS_SECOND
	XMIT $F0, AUX
	XOR R11, R5
	NZT R5, KU_PS_ELSE	
	;IF SCAN CODE IS $F0
	XMIT `HIGH KB_STATE, ADDR_HIGH
	XMIT `LOW KB_STATE, ADDR_LOW
	XMIT S_KB_READ_THIRD, DATA0, 8	;SET STATE TO S_KB_READ_THIRD
	XMIT `HIGH KB_SECOND_BUF, ADDR_HIGH
	XMIT `LOW KB_SECOND_BUF, ADDR_LOW
	MOVE R11, 8, DATA0	;PUT SCAN CODE IN KB_SECOND_BUF
	RET
KU_PS_ELSE
	XMIT `HIGH KB_STATE, ADDR_HIGH
	XMIT `LOW KB_STATE, ADDR_LOW
	XMIT S_KB_READ_FIRST, DATA0, 8
	XMIT `HIGH KB_FIRST_BUF, ADDR_HIGH
	XMIT `LOW KB_FIRST_BUF, ADDR_LOW
	MOVE DATA0, 8, R5	;PUT KB_FIRST_BUF IN R5
	XMIT `HIGH KB_FIRST, ADDR_HIGH
	XMIT `LOW KB_FIRST, ADDR_LOW
	MOVE R5, 8, DATA0	;PUT KB_FIRST_BUF IN KB_FIRST
	XMIT `HIGH KB_SECOND, ADDR_HIGH
	XMIT `LOW KB_SECOND, ADDR_LOW
	MOVE R11, 8, DATA0	;PUT SCAN CODE IN KB_SECOND
	RET
KU_PROCESS_THIRD
	XMIT `HIGH KB_STATE, ADDR_HIGH
	XMIT `LOW KB_STATE, ADDR_LOW
	XMIT S_KB_READ_FIRST, DATA0, 8	;SET KB_STATE TO S_KB_READ_FIRST
	XMIT `HIGH KB_FIRST_BUF, ADDR_HIGH
	XMIT `LOW KB_FIRST_BUF, ADDR_LOW
	MOVE DATA0, 8, R5	;PUT KB_FIRST_BUF IN R5
	XMIT `HIGH KB_FIRST, ADDR_HIGH
	XMIT `LOW KB_FIRST, ADDR_LOW
	MOVE R5, 8, DATA0	;PUT KB_FIRST_BUF IN KB_FIRST
	XMIT `HIGH KB_SECOND_BUF, ADDR_HIGH
	XMIT `LOW KB_SECOND_BUF, ADDR_LOW
	MOVE DATA0, 8, R5	;PUT KB_SECOND_BUF IN R5
	XMIT `HIGH KB_SECOND, ADDR_HIGH
	XMIT `LOW KB_SECOND, ADDR_LOW
	MOVE R5, 8, DATA0	;PUT KB_SECOND_BUF IN KB_SECOND
	XMIT `HIGH KB_THIRD, ADDR_HIGH
	XMIT `LOW KB_THIRD, ADDR_LOW
	MOVE R11, 8, DATA0	;PUT SCAN CODE IN KB_THIRD
	RET
KU_WAIT_BAT
;CHECK STATUS CODE
	XMIT $AA, AUX
	XOR R11, AUX
	NZT AUX, KWB_DONE	;IF CODE IS NOT $AA DO NOTHING
;CHECK THAT KB HOST IS READY
KWB_WAIT_TX
	XMIT `HIGH KB_STATUS, ADDR_HIGH
	XMIT `LOW KB_STATUS, ADDR_LOW	;KB STATUS REGISTER ADDRESS
	XMIT $01, AUX
	XOR IO2, 1, AUX	;READ TX DONE BIT
	NZT AUX, KWB_WAIT_TX	;WAIT UNTIL TX IS READY
;SEND SET LED COMMAND
	XMIT `HIGH KB_DATA, ADDR_HIGH
	XMIT `LOW KB_DATA, ADDR_LOW
	XMIT $ED, AUX
	MOVE AUX, 8, IO0
;UPDATE STATE
	XMIT `HIGH KB_STATE, ADDR_HIGH
	XMIT `LOW KB_STATE, ADDR_LOW
	XMIT S_KB_SET_LED, DATA0, 8	;SET KB_STATE TO S_KB_SET_LED
KWB_DONE
	RET
KU_SET_LED
;CHECK STATUS CODE
	XMIT $FA, AUX
	XOR R11, AUX
	NZT AUX, KSL_DONE	;IF CODE IS NOT $FA DO NOTHING
;CHECK THAT KB HOST IS REDY
KSL_WAIT_TX
	XMIT `HIGH KB_STATUS, ADDR_HIGH
	XMIT `LOW KB_STATUS, ADDR_LOW	;KB STATUS REGISTER ADDRESS
	XMIT $01, AUX
	XOR IO2, 1, AUX	;READ TX DONE BIT
	NZT AUX, KSL_WAIT_TX	;WAIT UNTIL TX IS READY
;SEND LED DATA
	XMIT `HIGH KB_DATA, ADDR_HIGH
	XMIT `LOW KB_DATA, ADDR_LOW
	XMIT $07, IO0, 8
;UPDATE STATE
	XMIT `HIGH KB_STATE, ADDR_HIGH
	XMIT `LOW KB_STATE, ADDR_LOW
	XMIT S_KB_READ_FIRST, DATA0, 8	;SET KB_STATE TO S_KB_READ_FIRST
KSL_DONE
	RET

PLOT_CELL
;FIRST CALCULATE THE DISPLAY ADDRESS BY SETTING THE ADDRESS TO DISPLAY_CELL_X AND ADDIGN DISPLAY_CELL_Y * 32
	XMIT `HIGH DISPLAY_CELL_X, ADDR_HIGH
	XMIT `LOW DISPLAY_CELL_X, ADDR_LOW
	XMIT $00, R6
	MOVE DATA0, 8, R11
	XMIT `HIGH DISPLAY_CELL_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_CELL_Y, ADDR_LOW
	XMIT $00, R4
	XMIT $20, R5
	MOVE DATA0, 8, R3
	XMIT `HIGH MACC_8_16, AUX
	CALL MACC_8_16
	XMIT `HIGH DISPLAY_CELL_VALUE, ADDR_HIGH
	XMIT `LOW DISPLAY_CELL_VALUE, ADDR_LOW
	MOVE DATA0, 8, AUX
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	NZT AUX, PC_NB
	XMIT $00, IO0, 7
	XMIT $01, IO7, 1
	RET
PC_NB
	XMIT $0F, IO0, 4
	MOVE AUX, 3, IO4
	XMIT $01, IO7, 1
	RET

PLOT_ELEMENT
;FIRST CALCULATE CELL X POSITION AND STORE IN MACC RESULT
	XMIT `HIGH DISPLAY_ELEMENT_X, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_X, ADDR_LOW
	XMIT $00, R6
	MOVE DATA1, 7, R11
;THEN CALCULATE CELL Y POSITION AND MULTIPLY BY 32, ADD RESULT TO X POSITION
	XMIT `HIGH DISPLAY_ELEMENT_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_Y, ADDR_LOW
	XMIT $00, R4
	XMIT $20, R5
	MOVE DATA1, 7, R3
	XMIT `HIGH MACC_8_16, AUX
	CALL MACC_8_16	;R6 AND R11 NOW CONTAIN THE CELL ADDRESS
;FIGURE OUT WHICH ELEMENT NEEDS TO BE MODIFIED
	XMIT `HIGH DISPLAY_ELEMENT_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_Y, ADDR_LOW
	MOVE DATA0, 1, R5
	MOVE DATA0, 1, AUX
	ADD R5, AUX
	XMIT `HIGH DISPLAY_ELEMENT_X, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_X, ADDR_LOW
	XOR DATA0, 1, R5	;R5 NOW INDICATES WHICH ELEMENT NEEDS TO BE MODIFIED
;GET THE ELEMENT VALUE AND DETERMINE IF IT IS BLACK
	XMIT `HIGH DISPLAY_ELEMENT_VALUE, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_VALUE, ADDR_LOW
	MOVE DATA0, 8, R4	;R4 NOW CONTAINS THE ELEMENT VALUE
	MOVE DATA0, 8, AUX
;COPY CURRENT CELL STATE TO IV LATCH SO WE CAN MODIFY IT
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	MOVE IO0, 8, IO0
	XMIT $01, IO7, 1
	NZT AUX, PE_NB
;IF THE ELEMENT IS BLACK TURN IT OFF AND RETURN
	XEC PE_CLEAR (R5) [4]
	RET
PE_CLEAR
	XMIT $00, IO3, 1
	XMIT $00, IO2, 1
	XMIT $00, IO1, 1
	XMIT $00, IO0, 1
PE_NB
;IF THE ELEMENT IS NOT BLACK TURN IT ON AND SET THE CELL COLOR
	MOVE R4, 3, IO4
	XEC PE_SET (R5) [4]
	RET
PE_SET
	XMIT $01, IO3, 1
	XMIT $01, IO2, 1
	XMIT $01, IO1, 1
	XMIT $01, IO0, 1

DISPLAY_PRINT	;L3
;FIRST CALCULATE THE DISPLAY ADDRESS
	XMIT `HIGH DISPLAY_CURSOR_X, ADDR_HIGH
	XMIT `LOW DISPLAY_CURSOR_X, ADDR_LOW
	XMIT $00, R6
	MOVE DATA0, 8, R11
	XMIT `HIGH DISPLAY_CURSOR_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_CURSOR_Y, ADDR_LOW
	XMIT $00, R4
	XMIT $20, R5
	MOVE DATA0, 8, R3
	XMIT `HIGH MACC_8_16, AUX
	CALL MACC_8_16
;CALCULATE STRING ADDRESS
	XMIT `HIGH STR_BUF, R4
	XMIT `LOW STR_BUF, R5
	JMP DP_UPDATE
DP_LOOP
	MOVE R3, 8, IO0
	MOVE R3(6), AUX
	XOR R3(5), AUX
	MOVE AUX, 1, IO6
	XMIT $01, AUX
	XOR R3(6), AUX
	MOVE AUX, 1, IO5	;CONVERT ASCII CODES FOR MC6847 (R3[7], R3[5] ^ R3[6], ~R3[6], R3[4:0])
DP_UPDATE
;INCREMENT STRING ADDRESS
	XMIT $01, AUX
	MOVE R4, ADDR_HIGH
	MOVE R5, ADDR_LOW
	ADD R5, R5
	MOVE OVF, AUX
	ADD R4, R4
	MOVE DATA0, 8, R3
;INCREMENT DISPLAY ADDRESS
	XMIT $01, AUX
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	ADD R11, R11
	MOVE OVF, AUX
	ADD R6, R6
;LOOP UNTILL WE GET A NULL BYTE
	NZT R3, DP_LOOP
	RET

GET_STRING	;L3
	XMIT $00, R5
	XMIT `HIGH STR_BUF_OFFSET, ADDR_HIGH
	XMIT `LOW STR_BUF_OFFSET, ADDR_LOW
	XMIT `HIGH STR_BUF, R6
	XMIT `LOW STR_BUF, R11
	MOVE DATA0, 8, AUX
	ADD R11, R11
	MOVE OVF, AUX
	ADD R6, R6
GS_LOOP
	XMIT $01, AUX
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	ADD R11, R11
	MOVE OVF, AUX
	ADD R6, R6
	XMIT `HIGH STR_SEL, AUX
	CALL STR_SEL
	XMIT $01, AUX
	ADD R5, R5
	MOVE R3, 8, DATA0
	NZT R3, GS_LOOP
	RET
STR_SEL	;L4
	XEC STR_LIST (R4) [5]
STR_LIST
	JMP S_SNAKE
	JMP S_SCORE
	JMP S_HIGH
	JMP S_BEGIN
	JMP S_GAME_OVER

	ORG $0400
MAIN	;L0
;INITIALIZE FRAME COUNT
	XMIT `HIGH FRAME_COUNT, ADDR_HIGH
	XMIT `LOW FRAME_COUNT, ADDR_LOW
	XMIT $00, DATA0, 8
	XMIT `HIGH HEX_INC, AUX
	CALL HEX_INC	;03
;CLEAR SCORE AND HIGH SCORE
	XMIT `HIGH SCORE, ADDR_HIGH
	XMIT `LOW SCORE, ADDR_LOW
	XMIT $00, DATA0, 8
	XMIT `HIGH HIGH_SCORE, ADDR_HIGH
	XMIT `LOW HIGH_SCORE, ADDR_LOW
	XMIT $00, DATA0, 8
;INITIALIZE THE SNAKE FSM
	XMIT `HIGH SNAKE_STATE, ADDR_HIGH
	XMIT `LOW SNAKE_STATE, ADDR_LOW
	XMIT S_SNAKE_HOME, DATA0
;ENABLE INTERRUPTS
	XMIT `HIGH INTERRUPT_CONTROL, ADDR_HIGH
	XMIT `LOW INTERRUPT_CONTROL, ADDR_LOW
	XMIT %0010 0101, AUX
	MOVE AUX, 8, IO0
MAIN_LOOP
; 0-RIGHT,1-LEFT,2-DOWN,3-UP,4-START,5-SEL,6-B,7-A
; CHECK BUTTONS TO SET DIRECTION
;NEW CODE
	XMIT `HIGH JP1_DATA, ADDR_HIGH
	XMIT `LOW JP1_DATA, ADDR_LOW
	XMIT $01, AUX
	ADD IO0, 8, AUX		;WILL CAUSE OVERFLOW IF NO JP IS PRESENT
	MOVE OVF, AUX
	NZT AUX, MAIN_LOOP
	XMIT $01, AUX
	XMIT $01, R1
;OLD CODE
	;XMIT `HIGH JP1_DATA, ADDR_HIGH
	;XMIT `LOW JP1_DATA, ADDR_LOW
	;XMIT $01, AUX
	;XMIT $01, R1
; CHECK UP BUTTON
	AND IO3, 1, R11
	NZT R11, ML_UPDATE_DIRECTION
	ADD R1, R1
; CHECK DOWN KEY
	AND IO2, 1, R11
	NZT R11, ML_UPDATE_DIRECTION
	ADD R1, R1
; CHECK LEFT KEY
	AND IO1, 1, R11
	NZT R11, ML_UPDATE_DIRECTION
	ADD R1, R1
; CHECK RIGHT KEY
	AND IO0, 1, R11
	NZT R11, ML_UPDATE_DIRECTION
	JMP MAIN_LOOP
ML_UPDATE_DIRECTION
	XMIT `HIGH HEAD_DIRECTION, ADDR_HIGH
	XMIT `LOW HEAD_DIRECTION, ADDR_LOW
	MOVE R1, 8, DATA0
	JMP MAIN_LOOP

KB_PROCESS	;L3
	XMIT `HIGH KB_FIRST, ADDR_HIGH
	XMIT `LOW KB_FIRST, ADDR_LOW
	MOVE DATA0, 8, R11
	NZT R11, KBP_HAS_CODE
	RET
KBP_HAS_CODE
; BIT ORDER: ENTER, SHIFT, UP, DOWN, LEFT, RIGHT
; MAKE CODES: 5A, 59, E0 75, E0 72, E0 6B, E0 74
; BREAK CODES: F0 5A, F0 59, E0 F0 75, E0 F0 72, E0 F0 6B, E0 F0 74
	XMIT $E0, AUX
	XOR R11, AUX
	NZT AUX, KBP_NOT_SPECIAL
; HANDLE SPECIAL CODES HERE
	XMIT `HIGH KB_SECOND, ADDR_HIGH
	XMIT `LOW KB_SECOND, ADDR_LOW
	MOVE DATA0, 8, R11
	XMIT $F0, AUX
	XOR R11, AUX
	NZT AUX, KBP_S_NOT_BREAK
; HANDLE SPECIAL BREAK CODES HERE
	XMIT `HIGH KB_THIRD, ADDR_HIGH
	XMIT `LOW KB_THIRD, ADDR_LOW
	MOVE DATA0, 8, R11
	XMIT `HIGH KEY_FLAGS, ADDR_HIGH
	XMIT `LOW KEY_FLAGS, ADDR_LOW
	;MOVE DATA0, 8, DATA0	;GET CURRENT KEY STATES
	XMIT $75, AUX
	XOR R11, AUX
	NZT AUX, KBP_SB_NOT_UP
	XMIT %1111 0111, AUX
	AND DATA0, 8, DATA0	;CLEAR UP KEY
	RET
KBP_SB_NOT_UP
	XMIT $72, AUX
	XOR R11, AUX
	NZT AUX, KBP_SB_NOT_DOWN
	XMIT %1111 1011, AUX
	AND DATA0, 8, DATA0	;CLEAR DOWN KEY
	RET
KBP_SB_NOT_DOWN
	XMIT $6B, AUX
	XOR R11, AUX
	NZT AUX, KBP_SB_NOT_LEFT
	XMIT %1111 1101, AUX
	AND DATA0, 8, DATA0	;CLEAR LEFT KEY
	RET
KBP_SB_NOT_LEFT
	XMIT $74, AUX
	XOR R11, AUX
	NZT AUX, KBP_SB_NOT_RIGHT
	XMIT %1111 1110, AUX
	AND DATA0, 8, DATA0	;CLEAR RIGHT KEY
	RET
KBP_SB_NOT_RIGHT
	RET
KBP_S_NOT_BREAK
; HANDLE SPECIAL MAKE CODES HERE
	XMIT `HIGH KEY_FLAGS, ADDR_HIGH
	XMIT `LOW KEY_FLAGS, ADDR_LOW
	;MOVE DATA0, 8, DATA0	;GET CURRENT KEY STATES
	XMIT $75, AUX,
	XOR R11, AUX
	NZT AUX, KBP_SM_NOT_UP
	XMIT %1111 0111, AUX
	AND DATA0, 8, DATA0
	XMIT %0000 1000, AUX
	XOR DATA0, 8, DATA0	;SET UP KEY
	RET
KBP_SM_NOT_UP
	XMIT $72, AUX
	XOR R11, AUX
	NZT AUX, KBP_SM_NOT_DOWN
	XMIT %1111 1011, AUX
	AND DATA0, 8, DATA0
	XMIT %0000 0100, AUX
	XOR DATA0, 8, DATA0	;SET DOWN KEY
	RET
KBP_SM_NOT_DOWN
	XMIT $6B, AUX
	XOR, R11, AUX
	NZT AUX, KBP_SM_NOT_LEFT
	XMIT %1111 1101, AUX
	AND DATA0, 8, DATA0
	XMIT %0000 0010, AUX
	XOR DATA0, 8, DATA0	;SET LEFT KEY
	RET
KBP_SM_NOT_LEFT
	XMIT $74, AUX
	XOR, R11, AUX
	NZT AUX, KBP_SM_NOT_RIGHT
	XMIT %1111 1110, AUX
	AND DATA0, 8, DATA0
	XMIT %0000 0001, AUX
	XOR DATA0, 8, DATA0	;SET RIGHT KEY
	RET
KBP_SM_NOT_RIGHT
	RET
KBP_NOT_SPECIAL
; HANDLE NORMAL CODES HERE
	XMIT $F0, AUX
	XOR R11, AUX
	NZT AUX, KBP_NS_NOT_BREAK
;HANDLE BREAK CODES HERE
	XMIT `HIGH KB_SECOND, ADDR_HIGH
	XMIT `LOW KB_SECOND, ADDR_LOW
	MOVE DATA0, 8, R11
	XMIT `HIGH KEY_FLAGS, ADDR_HIGH
	XMIT `LOW KEY_FLAGS, ADDR_LOW
	;MOVE DATA0, 8, DATA0	;GET CURRENT KEY STATES
	XMIT $5A, AUX
	XOR R11, AUX
	NZT AUX, KBP_B_NOT_ENTER
	XMIT %1101 1111, AUX
	AND DATA0, 8, DATA0	;CLEAR ENTER KEY
	RET
KBP_B_NOT_ENTER
	XMIT $59, AUX
	XOR R11, AUX
	NZT AUX, KBP_B_NOT_SHIFT
	XMIT %1110 1111, AUX
	AND DATA0, 8, DATA0	;CLEAR SHIFT KEY
	RET
KBP_B_NOT_SHIFT
	RET
KBP_NS_NOT_BREAK
;HANDLE MAKE CODES HERE
	XMIT `HIGH KEY_FLAGS, ADDR_HIGH
	XMIT `LOW KEY_FLAGS, ADDR_LOW
	;MOVE DATA0, 8, DATA0	;GET CURRENT KEY STATES
	XMIT $5A, AUX
	XOR R11, AUX
	NZT AUX, KBP_M_NOT_ENTER
	XMIT %1101 1111, AUX
	AND DATA0, 8, DATA0
	XMIT %0010 0000, AUX
	XOR DATA0, 8, DATA0	;SET ENTER KEY
	RET
KBP_M_NOT_ENTER
	XMIT $59, AUX
	XOR R11, AUX
	NZT AUX, KBP_M_NOT_SHIFT
	XMIT %1110 1111, AUX
	AND DATA0, 8, DATA0
	XMIT %0001 0000, AUX
	XOR DATA0, 8, DATA0	;SET SHIFT KEY
	RET
KBP_M_NOT_SHIFT
	RET

SN_NO_UPDATE
	RET
SNAKE_RUN
	XMIT `HIGH FRAME_COUNT, ADDR_HIGH
	XMIT `LOW FRAME_COUNT, ADDR_LOW
	XMIT $01, AUX
	XMIT 15, R5
	ADD DATA0, 8, R4	;GET AND INCREMENT FRAME COUNTER
	XMIT `HIGH DIV8, AUX
	CALL DIV8	;COMPUTE FRAME_COUNT % 15
	MOVE R4, 8, DATA0	;STORE RESULT IN FRAME COUNTER
	NZT R4, SN_NO_UPDATE	;IF FRAME_COUNT NOT ZERO JUMP TO SN_NO_UPDATE
	;XMIT `HIGH SNAKE_DUMP, AUX
	;CALL SNAKE_DUMP
M_RING_2	;L1
; LOAD CURRENT DIRECTION
	XMIT `HIGH HEAD_DIRECTION, ADDR_HIGH
	XMIT `LOW HEAD_DIRECTION, ADDR_LOW
	MOVE DATA0, 8, R1
MR2_APPLY_DIRECTION
; APPLY CURRENT DIRECTION TO HEAD
	XMIT `HIGH PLAYFIELD, R6
	XMIT `LOW PLAYFIELD, R11
	XMIT `HIGH HEAD_X, ADDR_HIGH
	XMIT `LOW HEAD_X, ADDR_LOW
	MOVE DATA0, 8, AUX
	ADD R11, R11
	MOVE OVF, AUX
	ADD R6, R6
	XMIT 64, MUL_IN_A
	XMIT `HIGH HEAD_Y, ADDR_HIGH
	XMIT `LOW HEAD_Y, ADDR_LOW
	XMIT $00, MUL_IN_B_H
	MOVE DATA0, 8, MUL_IN_B_L
	XMIT `HIGH MACC_8_16, AUX
	CALL MACC_8_16
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	MOVE, R1, 8, DATA0
; COMPUTE HEAD VELOCITY
	XEC MR2_CHX (R1) [5]
	XEC MR2_CHY (R1) [5]
	JMP MR2_COMPUTE_HEAD_POSITION
MR2_CHX
	XMIT $00, R11
	XMIT $00, R11
	XMIT $00, R11
	XMIT $FF, R11
	XMIT $01, R11
MR2_CHY
	XMIT $FF, R6
	XMIT $FF, R6
	XMIT $01, R6
	XMIT $00, R6
	XMIT $00, R6
MR2_COMPUTE_HEAD_POSITION
; COMPUTE NEW POSITION
	MOVE R11, AUX
	XMIT `HIGH HEAD_X, ADDR_HIGH
	XMIT `LOW HEAD_X, ADDR_LOW
	ADD DATA0, 8, R5
	ADD DATA0, 8, DATA0	;ADD X_VELOCITY TO HEAD_X, STORE RESULT IN HEAD_X AND R5
	MOVE R6, AUX
	XMIT `HIGH HEAD_Y, ADDR_HIGH
	XMIT `LOW HEAD_Y, ADDR_LOW
	ADD DATA0, 8, R4
	ADD DATA0, 8, DATA0	;ADD Y_VELOCITY TO HEAD_Y, STORE RESULT IN HEAD_Y AND R4
; CHECK FOR GAME OVER
	XMIT $C0, AUX
	AND R5, AUX
	NZT AUX, MR2_GAME_OVER
	XMIT $E0, AUX
	AND R4, AUX
	NZT AUX, MR2_GAME_OVER
; CHECK FOR COLLISION
	XMIT `HIGH PLAYFIELD, R6
	XMIT `LOW PLAYFIELD, R11
	XMIT `HIGH HEAD_X, ADDR_HIGH
	XMIT `LOW HEAD_X, ADDR_LOW
	MOVE DATA0, 8, AUX
	ADD R11, R11
	MOVE OVF, AUX
	ADD R6, R6
	XMIT 64, MUL_IN_A
	XMIT `HIGH HEAD_Y, ADDR_HIGH
	XMIT `LOW HEAD_Y, ADDR_LOW
	XMIT $00, MUL_IN_B_H
	MOVE DATA0, 8, MUL_IN_B_L
	XMIT `HIGH MACC_8_16, AUX
	CALL MACC_8_16
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	MOVE DATA0, 8, AUX
	NZT AUX, MR2_COLLISION
	JMP MR2_ANHD
MR2_GAME_OVER
	XMIT `HIGH SNAKE_STATE, ADDR_HIGH
	XMIT `LOW SNAKE_STATE, ADDR_LOW
	XMIT S_SNAKE_GAME_OVER, DATA0, 8
	RET
MR2_COLLISION
; CHECK FOR GAME OVER
	XMIT $05, AUX
	XOR DATA0, 8, AUX
	NZT AUX, MR2_GAME_OVER
; APPLY HEAD DIRECTION TO NEW HEAD
	MOVE R1, 8, DATA0
; PLOT NEW HEAD
	XMIT `HIGH HEAD_X, ADDR_HIGH
	XMIT `LOW HEAD_X, ADDR_LOW
	MOVE DATA0, 8, AUX
	XMIT `HIGH DISPLAY_ELEMENT_X, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_X, ADDR_LOW
	MOVE AUX, 8, DATA0	;COPY X HEAD_X TO DISPLAY_ELEMENT_X
	XMIT `HIGH HEAD_Y, ADDR_HIGH
	XMIT `LOW HEAD_Y, ADDR_LOW
	MOVE DATA0, 8, AUX
	XMIT `HIGH DISPLAY_ELEMENT_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_Y, ADDR_LOW
	MOVE AUX, 8, DATA0	;COPY HEAD_Y TO_DISPLAY_ELEMENT_Y
	XMIT `HIGH DISPLAY_ELEMENT_VALUE, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_VALUE, ADDR_LOW
	XMIT SG4_GREEN, DATA0, 8	;SET ELEMENT COLOR
	XMIT `HIGH PLOT_ELEMENT, AUX
	CALL PLOT_ELEMENT
; INCREMENT SCORE
	XMIT $01, AUX
	XMIT `HIGH SCORE, ADDR_HIGH
	XMIT `LOW SCORE, ADDR_LOW
	ADD DATA0, 8, DATA0
; COMPUTE NEW TARGET POSITION
MR2_CTP
; GET TARGET_X
	XMIT `HIGH RND_BUILD_BYTE, AUX
	CALL RND_BUILD_BYTE
	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	XMIT $40, DENOMINATOR
	MOVE DATA0, 8, NUMERATOR
	XMIT `HIGH DIV8, AUX
	CALL DIV8
	XMIT `HIGH TARGET_X, ADDR_HIGH
	XMIT `LOW TARGET_X, ADDR_LOW
	MOVE NUMERATOR, 8, DATA0
; GET TARGET_Y
	XMIT `HIGH RND_BUILD_BYTE, AUX
	CALL RND_BUILD_BYTE
	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	XMIT $20, DENOMINATOR
	MOVE DATA0, 8, NUMERATOR
	XMIT `HIGH DIV8, AUX
	CALL DIV8
	XMIT `HIGH TARGET_Y, ADDR_HIGH
	XMIT `LOW TARGET_Y, ADDR_LOW
	MOVE NUMERATOR, 8, DATA0
; COMPUTE PLAYFIELD ADDRESS
	XMIT `HIGH TARGET_X, ADDR_HIGH
	XMIT `LOW TARGET_X, ADDR_LOW
	XMIT `HIGH PLAYFIELD, R6
	XMIT `LOW PLAYFIELD, R11
	MOVE DATA0, 8, AUX
	ADD R11, R11
	MOVE OVF, AUX
	ADD R6, R6
	XMIT 64, R3
	MOVE R4, R5
	XMIT $00, R4
	XMIT `HIGH MACC_8_16, AUX
	CALL MACC_8_16
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	MOVE DATA0, 8, AUX
	NZT AUX, MR2_CTP
; CREATE TARGET IN PLAYFIELD
	XMIT $05, DATA0, 8
; PLOT TARGET
	XMIT `HIGH TARGET_X, ADDR_HIGH
	XMIT `LOW TARGET_X, ADDR_LOW
	MOVE DATA0, 8, AUX
	XMIT `HIGH DISPLAY_ELEMENT_X, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_X, ADDR_LOW
	MOVE AUX, 8, DATA0	;COPY X TARGET_X TO DISPLAY_ELEMENT_X
	XMIT `HIGH TARGET_Y, ADDR_HIGH
	XMIT `LOW TARGET_Y, ADDR_LOW
	MOVE DATA0, 8, AUX
	XMIT `HIGH DISPLAY_ELEMENT_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_Y, ADDR_LOW
	MOVE AUX, 8, DATA0	;COPY TARGET_Y TO_DISPLAY_ELEMENT_Y
	XMIT `HIGH DISPLAY_ELEMENT_VALUE, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_VALUE, ADDR_LOW
	XMIT SG4_BLUE, DATA0, 8	;SET ELEMENT COLOR
	XMIT `HIGH PLOT_ELEMENT, AUX
	CALL PLOT_ELEMENT
	RET
MR2_ANHD
; APPLY HEAD DIRECTION TO NEW HEAD
	MOVE R1, 8, DATA0
; PLOT THE NEW HEAD
	XMIT `HIGH HEAD_X, ADDR_HIGH
	XMIT `LOW HEAD_X, ADDR_LOW
	MOVE DATA0, 8, AUX
	XMIT `HIGH DISPLAY_ELEMENT_X, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_X, ADDR_LOW
	MOVE AUX, 8, DATA0	;COPY X HEAD_X TO DISPLAY_ELEMENT_X
	XMIT `HIGH HEAD_Y, ADDR_HIGH
	XMIT `LOW HEAD_Y, ADDR_LOW
	MOVE DATA0, 8, AUX
	XMIT `HIGH DISPLAY_ELEMENT_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_Y, ADDR_LOW
	MOVE AUX, 8, DATA0	;COPY HEAD_Y TO_DISPLAY_ELEMENT_Y
	XMIT `HIGH DISPLAY_ELEMENT_VALUE, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_VALUE, ADDR_LOW
	XMIT SG4_GREEN, DATA0, 8	;SET ELEMENT COLOR
	XMIT `HIGH PLOT_ELEMENT, AUX
	CALL PLOT_ELEMENT
; GET TAIL DIRECTION
	XMIT `HIGH PLAYFIELD, R6
	XMIT `LOW PLAYFIELD, R11
	XMIT `HIGH TAIL_X, ADDR_HIGH
	XMIT `LOW TAIL_X, ADDR_LOW
	MOVE DATA0, 8, AUX
	ADD R11, R11
	MOVE OVF, AUX
	ADD R6, R6
	XMIT 64, MUL_IN_A
	XMIT `HIGH TAIL_Y, ADDR_HIGH
	XMIT `LOW TAIL_Y, ADDR_LOW
	XMIT $00, MUL_IN_B_H
	MOVE DATA0, 8, MUL_IN_B_L
	XMIT `HIGH MACC_8_16, AUX
	CALL MACC_8_16
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	MOVE DATA0, 8, R2
	XMIT $00, DATA0, 8	;DESTROY TAIL IN PLAYFIELD
	XMIT `HIGH TAIL_DIRECTION, ADDR_HIGH
	XMIT `LOW TAIL_DIRECTION, ADDR_LOW
	MOVE R2, 8, DATA0
; DELETE OLD TAIL
	XMIT `HIGH TAIL_X, ADDR_HIGH
	XMIT `LOW TAIL_X, ADDR_LOW
	MOVE DATA0, 8, AUX
	XMIT `HIGH DISPLAY_ELEMENT_X, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_X, ADDR_LOW
	MOVE AUX, 8, DATA0	;COPY X TAIL_X TO DISPLAY_ELEMENT_X
	XMIT `HIGH TAIL_Y, ADDR_HIGH
	XMIT `LOW TAIL_Y, ADDR_LOW
	MOVE DATA0, 8, AUX
	XMIT `HIGH DISPLAY_ELEMENT_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_Y, ADDR_LOW
	MOVE AUX, 8, DATA0	;COPY TAIL_Y TO_DISPLAY_ELEMENT_Y
	XMIT `HIGH DISPLAY_ELEMENT_VALUE, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_VALUE, ADDR_LOW
	XMIT SG4_BLACK, DATA0, 8	;SET ELEMENT COLOR
	XMIT `HIGH PLOT_ELEMENT, AUX
	CALL PLOT_ELEMENT
; COMPUTE TAIL VELOCITY
	XMIT `HIGH TAIL_DIRECTION, ADDR_HIGH
	XMIT `LOW TAIL_DIRECTION, ADDR_LOW
	MOVE DATA0, 8, AUX
	XEC MR2_CTX (AUX) [5]
	XEC MR2_CTY (AUX) [5]
	JMP MR2_UPDATE_TAIL_POSITION
MR2_CTX
	XMIT $00, R11
	XMIT $00, R11
	XMIT $00, R11
	XMIT $FF, R11
	XMIT $01, R11
MR2_CTY
	XMIT $FF, R6
	XMIT $FF, R6
	XMIT $01, R6
	XMIT $00, R6
	XMIT $00, R6
MR2_UPDATE_TAIL_POSITION
; UPDATE TAIL POSITION
	MOVE R11, AUX
	XMIT `HIGH TAIL_X, ADDR_HIGH
	XMIT `LOW TAIL_X, ADDR_LOW
	ADD DATA0, 8, DATA0	;ADD X_VELOCITY TO TAIL_X
	MOVE R6, AUX
	XMIT `HIGH TAIL_Y, ADDR_HIGH
	XMIT `LOW TAIL_Y, ADDR_LOW
	ADD DATA0, 8, DATA0	;ADD Y_VELOCITY TO TAIL_Y
	RET

MR2_TEST
	XMIT `HIGH RND_BUILD_BYTE, AUX
	CALL RND_BUILD_BYTE
	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	;XMIT $20, R5
	XMIT $40, R5
	MOVE DATA0, 8, R4
	XMIT `HIGH DIV8, AUX
	CALL DIV8
	;XMIT `HIGH DISPLAY_CELL_X, ADDR_HIGH
	;XMIT `LOW DISPLAY_CELL_X, ADDR_LOW
	XMIT `HIGH DISPLAY_ELEMENT_X, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_X, ADDR_LOW
	MOVE R4, 8, DATA0

	XMIT `HIGH RND_BUILD_BYTE, AUX
	CALL RND_BUILD_BYTE
	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	;XMIT $10, R5
	XMIT $20, R5
	MOVE DATA0, 8, R4
	XMIT `HIGH DIV8, AUX
	CALL DIV8
	;XMIT `HIGH DISPLAY_CELL_Y, ADDR_HIGH
	;XMIT `LOW DISPLAY_CELL_Y, ADDR_LOW
	XMIT `HIGH DISPLAY_ELEMENT_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_Y, ADDR_LOW
	MOVE R4, 8, DATA0

	XMIT `HIGH RND_BUILD_BYTE, AUX
	CALL RND_BUILD_BYTE
	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	XMIT $09, R5
	MOVE DATA0, 8, R4
	XMIT `HIGH DIV8, AUX
	CALL DIV8
	;XMIT `HIGH DISPLAY_CELL_VALUE, ADDR_HIGH
	;XMIT `LOW DISPLAY_CELL_VALUE, ADDR_LOW
	XMIT `HIGH DISPLAY_ELEMENT_VALUE, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_VALUE, ADDR_LOW
	MOVE R4, 8, DATA0

	;XMIT `HIGH PLOT_CELL, AUX
	;CALL PLOT_CELL
	XMIT `HIGH PLOT_ELEMENT, AUX
	CALL PLOT_ELEMENT
	RET

GET_HIGH_SCORE
	XMIT `HIGH HIGH_SCORE, ADDR_HIGH
	XMIT `LOW HIGH_SCORE, ADDR_LOW
	MOVE DATA0, 8, R4	;SET NUMERATOR TO HIGH SCORE
	XMIT `HIGH STR_BUF_OFFSET, ADDR_HIGH
	XMIT `LOW STR_BUF_OFFSET, ADDR_LOW
	XMIT 14, DATA0, 8	;SET STRING OFFSET TO 14
	JMP TO_STR
GET_SCORE
	XMIT `HIGH SCORE, ADDR_HIGH
	XMIT `LOW SCORE, ADDR_LOW
	MOVE DATA0, 8, R4	;SET NUMERATOR TO SCORE
	XMIT `HIGH STR_BUF_OFFSET, ADDR_HIGH
	XMIT `LOW STR_BUF_OFFSET, ADDR_LOW
	XMIT 14, DATA0, 8	;SET STRING OFFSET TO 14
TO_STR
	XMIT $03, R2	;SET LOOP COUNTER TO 3
	XMIT 10, R5	;SET DENOMINATOR TO 10
TSTR_LOOP
	XMIT `HIGH DIV8, AUX
	CALL DIV8
	XMIT $30, AUX
	ADD R4, R1	;CONVERT REMAINDER TO CHAR AND STORE IN R1
	MOVE R11, R4	;MAKE THE RESULT THE NEW NUMERATOR
; COMPUTE STRING ADDRES
	XMIT `HIGH STR_BUF_OFFSET, ADDR_HIGH
	XMIT `LOW STR_BUF_OFFSET, ADDR_LOW
	XMIT `HIGH STR_BUF, R6
	XMIT `LOW STR_BUF, R11
	MOVE DATA0, 8, AUX
	ADD R11, R11
	MOVE OVF, AUX
	ADD R6, R6
; DECREMENT STRING OFFSET
	XMIT $FF, AUX
	XMIT `HIGH STR_BUF_OFFSET, ADDR_HIGH
	XMIT `LOW STR_BUF_OFFSET, ADDR_LOW
	ADD DATA0, 8, DATA0
; WRITE CHAR
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	MOVE R1, 8, DATA0
; DECREMENT COUNTER AND LOOP
	XMIT $FF, AUX
	ADD R2, R2
	NZT R2, TSTR_LOOP
; TERMINATE THE STRING
	XMIT $03, AUX
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	ADD R11, R11
	MOVE OVF, AUX
	ADD R6, R6
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	XMIT $00, DATA0, 8
	RET

	ORG $0600
SNAKE_PAUSE
	RET

SNAKE_GAME_OVER	;L2
; UPDATE HIGH SCORE
	XMIT `HIGH SCORE, ADDR_HIGH
	XMIT `LOW SCORE, ADDR_LOW
	XMIT $FF, AUX
	MOVE DATA0, R1	;GET SCORE IN R1
	XMIT `HIGH HIGH_SCORE, ADDR_HIGH
	XMIT `LOW HIGH_SCORE, ADDR_LOW
	XOR R1, R2	;GET ~SCORE IN R2
	XMIT $01, AUX
	MOVE DATA0, R3	;GET HIGH_SCORE IN R3
	ADD R2, AUX		;GET -SCORE IN AUX
	ADD R3, R3		;COMPUTE HIGH_SCORE - SCORE
	XMIT $01, AUX
	AND R3(7), R3
	XOR R3, AUX 
	NZT AUX, GO_NO_UPDATE	;IF RESULT IS NOT NEGATIVE SKIP UPDATE
	MOVE R1, DATA0
GO_NO_UPDATE
; PRINT GAME OVER STRING
	XMIT `HIGH STR_BUF_OFFSET, ADDR_HIGH
	XMIT `LOW STR_BUF_OFFSET, ADDR_LOW
	XMIT $00, DATA0, 8	;SET STRING OFFSET
	XMIT `HIGH DISPLAY_CURSOR_X, ADDR_HIGH
	XMIT `LOW DISPLAY_CURSOR_X, ADDR_LOW
	XMIT $0C, DATA0, 8	;SET X POSITION
	XMIT `HIGH DISPLAY_CURSOR_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_CURSOR_Y, ADDR_LOW
	XMIT $04, DATA0, 8
	XMIT $04, R4	;SELECT STRING 4
	XMIT `HIGH  GET_STRING, AUX
	CALL GET_STRING
	XMIT `HIGH DISPLAY_PRINT, AUX
	CALL DISPLAY_PRINT
	JMP PRINT_SCORE
SNAKE_HOME
; PRINT SNAKE STRING
	XMIT `HIGH STR_BUF_OFFSET, ADDR_HIGH
	XMIT `LOW STR_BUF_OFFSET, ADDR_LOW
	XMIT $00, DATA0, 8	;SET STRING OFFSET
	XMIT `HIGH DISPLAY_CURSOR_X, ADDR_HIGH
	XMIT `LOW DISPLAY_CURSOR_X, ADDR_LOW
	XMIT $0B, DATA0, 8	;SET X POSITION
	XMIT `HIGH DISPLAY_CURSOR_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_CURSOR_Y, ADDR_LOW
	XMIT $04, DATA0, 8
	XMIT $00, R4	;SELECT STRING 0
	XMIT `HIGH  GET_STRING, AUX
	CALL GET_STRING
	XMIT `HIGH DISPLAY_PRINT, AUX
	CALL DISPLAY_PRINT
PRINT_SCORE
	XMIT `HIGH DISPLAY_CURSOR_X, ADDR_HIGH
	XMIT `LOW DISPLAY_CURSOR_X, ADDR_LOW
	XMIT $00, DATA0, 8	;SET CURSOR X POSITION
	XMIT `HIGH DISPLAY_CURSOR_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_CURSOR_Y, ADDR_LOW
	XMIT $00, DATA0, 8	;SET CURSOR Y POSITION
	XMIT $01, R4	;SELECT STRING 1
	XMIT `HIGH GET_STRING, AUX
	CALL GET_STRING
	XMIT `HIGH GET_SCORE, AUX
	CALL GET_SCORE
	XMIT `HIGH DISPLAY_PRINT, AUX
	CALL DISPLAY_PRINT
; PRINT HIGH SCORE
	XMIT `HIGH STR_BUF_OFFSET, ADDR_HIGH
	XMIT `LOW STR_BUF_OFFSET, ADDR_LOW
	XMIT $00, DATA0, 8	;SET STRING OFFSET
	XMIT `HIGH DISPLAY_CURSOR_X, ADDR_HIGH
	XMIT `LOW DISPLAY_CURSOR_X, ADDR_LOW
	XMIT $11, DATA0, 8	;SET X POSITION
	XMIT $02, R4	;SELECT STRING 2
	XMIT `HIGH  GET_STRING, AUX
	CALL GET_STRING
	XMIT `HIGH GET_HIGH_SCORE, AUX
	CALL GET_HIGH_SCORE
	XMIT `HIGH DISPLAY_PRINT, AUX
	CALL DISPLAY_PRINT
; PRINT BEGIN STRING
	XMIT `HIGH STR_BUF_OFFSET, ADDR_HIGH
	XMIT `LOW STR_BUF_OFFSET, ADDR_LOW
	XMIT $00, DATA0, 8	;SET STRING OFFSET
	XMIT `HIGH DISPLAY_CURSOR_X, ADDR_HIGH
	XMIT `LOW DISPLAY_CURSOR_X, ADDR_LOW
	XMIT $03, DATA0, 8	;SET X POSITION
	XMIT `HIGH DISPLAY_CURSOR_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_CURSOR_Y, ADDR_LOW
	XMIT $0C, DATA0, 8
	XMIT $03, R4	;SELECT STRING 3
	XMIT `HIGH  GET_STRING, AUX
	CALL GET_STRING
	XMIT `HIGH DISPLAY_PRINT, AUX
	CALL DISPLAY_PRINT
; UPDATE STATE TO SNAKE_WAIT
	XMIT `HIGH SNAKE_STATE, ADDR_HIGH
	XMIT `LOW SNAKE_STATE, ADDR_LOW
	XMIT S_SNAKE_WAIT, DATA0, 8
	RET

; WAIT FOR KEY PRESS
SNAKE_WAIT
	XMIT $01, AUX
	XMIT `HIGH JP1_DATA, ADDR_HIGH
	XMIT `LOW JP1_DATA, ADDR_LOW
; CHECK IF THERE IS A JOYPAD PLUGGED IN
;NEW CODE
	ADD IO0, 8, AUX		;WILL CAUSE OVERFLOW IF NO JP IS PRESENT
	XMIT $01, AUX
	XOR OVF, AUX
	AND IO4, 1, AUX		;JP IS PRESENT AND BUTTON IS PRESSED
	NZT AUX, SW_P
;OLD CODE
	;AND IO4, 1, AUX
	;NZT AUX, SW_P

	XMIT $01, AUX
	XMIT `HIGH KEY_FLAGS, ADDR_HIGH
	XMIT `LOW KEY_FLAGS, ADDR_LOW
	XOR DATA4, 1, AUX
	NZT AUX, SW_NP
SW_P
	XMIT `HIGH SNAKE_STATE, ADDR_HIGH
	XMIT `LOW SNAKE_STATE, ADDR_LOW
	XMIT S_SNAKE_RESET, DATA0, 8
SW_NP
	RET

SNAKE_RESET
; CLEAR SCORE
	XMIT `HIGH SCORE, ADDR_HIGH
	XMIT `LOW SCORE, ADDR_LOW
	XMIT $00, DATA0, 8
; CLEAR SCREEN
	XMIT $80, R3
	XMIT `HIGH DISPLAY_INIT_SG4, AUX
	CALL DISPLAY_INIT_SG4
; CLEAR PLAYFIELD
	XMIT `HIGH PLAYFIELD, R6
	XMIT `LOW PLAYFIELD, R11
SR_CP_LOOP
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	XMIT $00, DATA0, 8
	XMIT $01, AUX
	ADD R11, R11
	MOVE OVF, AUX
	ADD R6, R6
	XMIT `HIGH PLAYFIELD_END, AUX
	XOR R6, AUX
	NZT AUX, SR_CP_LOOP
	XMIT `LOW PLAYFIELD_END, AUX
	XOR R11, AUX
	NZT AUX, SR_CP_LOOP
; CREATE HEAD
	XMIT `HIGH HEAD_X, ADDR_HIGH
	XMIT `LOW HEAD_X, ADDR_LOW
	XMIT 12, DATA0, 8
	XMIT `HIGH HEAD_Y, ADDR_HIGH
	XMIT `LOW HEAD_Y, ADDR_LOW
	XMIT 12, DATA0, 8
	XMIT `HIGH PLAYFIELD, R6
	XMIT `LOW PLAYFIELD, R11
	XMIT 12, AUX
	ADD R11, R11
	MOVE OVF, AUX
	ADD R6, R6
	XMIT 64, R3
	XMIT 12, R5
	XMIT $00, R4
	XMIT `HIGH MACC_8_16, AUX
	CALL MACC_8_16
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	XMIT $01, DATA0, 8
	XMIT `HIGH HEAD_DIRECTION, ADDR_HIGH
	XMIT `LOW HEAD_DIRECTION, ADDR_LOW
	XMIT $01, DATA0, 8
	XMIT `HIGH HEAD_X, ADDR_HIGH
	XMIT `LOW HEAD_X, ADDR_LOW
	MOVE DATA0, 8, AUX
	XMIT `HIGH DISPLAY_ELEMENT_X, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_X, ADDR_LOW
	MOVE AUX, 8, DATA0	;COPY X HEAD_X TO DISPLAY_ELEMENT_X
	XMIT `HIGH HEAD_Y, ADDR_HIGH
	XMIT `LOW HEAD_Y, ADDR_LOW
	MOVE DATA0, 8, AUX
	XMIT `HIGH DISPLAY_ELEMENT_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_Y, ADDR_LOW
	MOVE AUX, 8, DATA0	;COPY HEAD_Y TO_DISPLAY_ELEMENT_Y
	XMIT `HIGH DISPLAY_ELEMENT_VALUE, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_VALUE, ADDR_LOW
	XMIT SG4_GREEN, DATA0, 8	;SET ELEMENT COLOR
	XMIT `HIGH PLOT_ELEMENT, AUX
	CALL PLOT_ELEMENT
; CREATE TAIL
	XMIT `HIGH TAIL_X, ADDR_HIGH
	XMIT `LOW TAIL_X, ADDR_LOW
	XMIT 12, DATA0, 8
	XMIT `HIGH TAIL_Y, ADDR_HIGH
	XMIT `LOW TAIL_Y, ADDR_LOW
	XMIT 13, DATA0, 8
	XMIT `HIGH PLAYFIELD, R6
	XMIT `LOW PLAYFIELD, R11
	XMIT 12, AUX
	ADD R11, R11
	MOVE OVF, AUX
	ADD R6, R6
	XMIT 64, R3
	XMIT 13, R5
	XMIT $00, R4
	XMIT `HIGH MACC_8_16, AUX
	CALL MACC_8_16
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	XMIT $01, DATA0, 8
	XMIT `HIGH TAIL_DIRECTION, ADDR_HIGH
	XMIT `LOW TAIL_DIRECTION, ADDR_LOW
	XMIT $01, DATA0, 8
	XMIT `HIGH TAIL_X, ADDR_HIGH
	XMIT `LOW TAIL_X, ADDR_LOW
	MOVE DATA0, 8, AUX
	XMIT `HIGH DISPLAY_ELEMENT_X, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_X, ADDR_LOW
	MOVE AUX, 8, DATA0	;COPY X TAIL_X TO DISPLAY_ELEMENT_X
	XMIT `HIGH TAIL_Y, ADDR_HIGH
	XMIT `LOW TAIL_Y, ADDR_LOW
	MOVE DATA0, 8, AUX
	XMIT `HIGH DISPLAY_ELEMENT_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_Y, ADDR_LOW
	MOVE AUX, 8, DATA0	;COPY TAIL_Y TO_DISPLAY_ELEMENT_Y
	XMIT `HIGH DISPLAY_ELEMENT_VALUE, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_VALUE, ADDR_LOW
	XMIT SG4_GREEN, DATA0, 8	;SET ELEMENT COLOR
	XMIT `HIGH PLOT_ELEMENT, AUX
	CALL PLOT_ELEMENT
; CREATE TARGET
	XMIT `HIGH TARGET_X, ADDR_HIGH
	XMIT `LOW TARGET_X, ADDR_LOW
	XMIT 16, DATA0, 8
	XMIT `HIGH TARGET_Y, ADDR_HIGH
	XMIT `LOW TARGET_Y, ADDR_LOW
	XMIT 8, DATA0, 8
	XMIT `HIGH PLAYFIELD, R6
	XMIT `LOW PLAYFIELD, R11
	XMIT 16, AUX
	ADD R11, R11
	MOVE OVF, AUX
	ADD R6, R6
	XMIT 64, R3
	XMIT 8, R5
	XMIT $00, R4
	XMIT `HIGH MACC_8_16, AUX
	CALL MACC_8_16
	MOVE R6, ADDR_HIGH
	MOVE R11, ADDR_LOW
	XMIT $05, DATA0, 8
	XMIT `HIGH TARGET_X, ADDR_HIGH
	XMIT `LOW TARGET_X, ADDR_LOW
	MOVE DATA0, 8, AUX
	XMIT `HIGH DISPLAY_ELEMENT_X, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_X, ADDR_LOW
	MOVE AUX, 8, DATA0	;COPY X TARGET_X TO DISPLAY_ELEMENT_X
	XMIT `HIGH TARGET_Y, ADDR_HIGH
	XMIT `LOW TARGET_Y, ADDR_LOW
	MOVE DATA0, 8, AUX
	XMIT `HIGH DISPLAY_ELEMENT_Y, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_Y, ADDR_LOW
	MOVE AUX, 8, DATA0	;COPY TARGET_Y TO_DISPLAY_ELEMENT_Y
	XMIT `HIGH DISPLAY_ELEMENT_VALUE, ADDR_HIGH
	XMIT `LOW DISPLAY_ELEMENT_VALUE, ADDR_LOW
	XMIT SG4_BLUE, DATA0, 8	;SET ELEMENT COLOR
	XMIT `HIGH PLOT_ELEMENT, AUX
	CALL PLOT_ELEMENT
	XMIT `HIGH SNAKE_STATE, ADDR_HIGH
	XMIT `LOW SNAKE_STATE, ADDR_LOW
	XMIT S_SNAKE_RUN, DATA0, 8
	RET

MR2_KB_TEST
	XMIT `HIGH KEY_FLAGS, ADDR_HIGH
	XMIT `LOW KEY_FLAGS, ADDR_LOW
	MOVE DATA0, 8, R11
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
	RET

;NOTE: LABELS ON ORG STATEMENTS CANNOT BE REFERENCED IN THE CODE! THESE DO NOT BELONG TO ANY SEGMENT AND WILL NOT BE FOUND.
STRINGS	ORG $0700
S_HEX
	XEC HEX_0 (R5) [16]	;CHARS 0 - F
	RET
HEX_0
	XMIT $30, R5
	XMIT $31, R5
	XMIT $32, R5
	XMIT $33, R5
	XMIT $34, R5
	XMIT $35, R5
	XMIT $36, R5
	XMIT $37, R5
	XMIT $38, R5
	XMIT $39, R5
	XMIT $41, R5
	XMIT $42, R5
	XMIT $43, R5
	XMIT $44, R5
	XMIT $45, R5
	XMIT $46, R5

S_SNAKE
	XEC SNAKE_0 (R5) [11]
	RET
SNAKE_0
	XMIT 'S', R3
	XMIT 'N', R3
	XMIT 'A', R3
	XMIT 'K', R3
	XMIT 'E', R3
	XMIT '\S', R3
	XMIT 'G', R3
	XMIT 'A', R3
	XMIT 'M', R3
	XMIT 'E', R3
	XMIT '\0', R3

S_SCORE
	XEC SCORE_0 (R5) [12]
	RET
SCORE_0
	XMIT 'Y', R3
	XMIT 'O', R3
	XMIT 'U', R3
	XMIT 'R', R3
	XMIT '\S', R3
	XMIT 'S', R3
	XMIT 'C', R3
	XMIT 'O', R3
	XMIT 'R', R3
	XMIT 'E', R3
	XMIT ':', R3
	XMIT '\S', R3
	XMIT '\0', R3

S_HIGH
	XEC HIGH_0 (R5) [12]
	RET
HIGH_0
	XMIT 'H', R3
	XMIT 'I', R3
	XMIT 'G', R3
	XMIT 'H', R3
	XMIT '\S', R3
	XMIT 'S', R3
	XMIT 'C', R3
	XMIT 'O', R3
	XMIT 'R', R3
	XMIT 'E', R3
	XMIT ':', R3
	XMIT '\S', R3
	XMIT '\0', R3

S_BEGIN
	XEC BEGIN_0 (R5) [27]
	RET
BEGIN_0
	XMIT 'P', R3
	XMIT 'R', R3
	XMIT 'E', R3
	XMIT 'S', R3
	XMIT 'S', R3
	XMIT '\S', R3
	XMIT 'R', R3
	XMIT 'I', R3
	XMIT 'G', R3
	XMIT 'H', R3
	XMIT 'T', R3
	XMIT '\S', R3
	XMIT 'S', R3
	XMIT 'H', R3
	XMIT 'I', R3
	XMIT 'F', R3
	XMIT 'T', R3
	XMIT '\S', R3
	XMIT 'T', R3
	XMIT 'O', R3
	XMIT '\S', R3
	XMIT 'B', R3
	XMIT 'E', R3
	XMIT 'G', R3
	XMIT 'I', R3
	XMIT 'N', R3
	XMIT '\0', R3

S_GAME_OVER
	XEC GAME_OVER_0 (R5) [10]
	RET
GAME_OVER_0
	XMIT 'G', R3
	XMIT 'A', R3
	XMIT 'M', R3
	XMIT 'E', R3
	XMIT '\S', R3
	XMIT 'O', R3
	XMIT 'V', R3
	XMIT 'E', R3
	XMIT 'R', R3
	XMIT '\0', R3

	ORG $0FFF	;PAD FILE TO 4K WORDS
	JMP INIT
